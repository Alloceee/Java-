# 反射

- 什么是反射

  - Java反射机制是在运行状态中，对于任意一个类都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意方法和属性。这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制

- 反射的例子

  - 获取方法
    - Class c = Class.forName("全路径")
    - Robot r = (Robot)c.newInstance();//返回一个泛型，需要强制转化
    - Method getHello = rc.getDeclaredMethod("方法名称"，String.class(方法需要一个String类型的参数))
      - getDeclaredMethod()可以获取私有和公有方法，但是不能获取继承的方法或者实现接口的方法
      - getMethod()只能获取类中public方法，但还能获取继承类的公有方法和接口实现的方法
    - getHello.setAccessible(true);
      - 默认是false。私有方法必须设置为true
    - Object str = getHello.invoke(r,"bb");
      - invoke执行方法，返回Object对象，参数一为对象实例，参数二为传入的参数
  - 获取变量
    - Field name = r.getDeclaredField("变量名");
    - name.setAccessible(true);
      - 私有变量设置true
    - name.set(r,"Alice");
      - 赋值私有变量，参数一为对象实例，参数二为要赋的值
    - Field[] fields = r.getDeclaredFields();//获取全部属性

- 通过反射实现对象的Clone

   ```java
    import java.io.*;
    /**
    * @author AlmostLover
    */
    public class MyUtil {
    private MyUtil() {
        throw new AssertionError();
    }
    
    public static <T extends Serializable> T clone(T obj) throws Exception {
        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bout);
        oos.writeObject(obj);
        ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bin);
        return (T) ois.readObject();
       }
    }
   ```
  ```
    /**
     * 使用序列化实现真正的深克隆
     * 基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象
     * 是否支持序列化，这项检测是编译器完成的，不是在运行时抛出异常，优先于Object的clone方法
     * @author AlmostLover
     */
    public class CloneTest {
        public static void main(String[] args) {
            /**
             *修改克隆Person对象关联的汽车品牌属性，原来的Person的汽车不会受到影响，因为在克隆Person
             * 对象时其关联的汽车对象也被克隆了
             */
            Person person1 = new Person("张三",33,new Car("Benz",300));
            try {
                Person person2 = MyUtil.clone(person1);
                person2.getCar().setBrand("BYD");
                System.out.println(person1);
                System.out.println(person2);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
  ```
  
  
  
- 获取字节码的三种方法

  - Class.forName(className)
  - 类名.class
  - this.getClass()

- 应用场景

  - 逆向代码，例如反编译
  - 与注解相结合的框架，例如Retrofit
  - 单纯的反射机制应用框架，例如EventBus 2.x
  - 动态生成类框架，例如Gson