### 1.面向对象和面向过程的区别

#### 面向过程

优点：性能比面向对象高，因为类调用时需要实力化，开销比较大，比较消耗资源；比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。

缺点：没有面向对象易维护、易复用、易扩展

#### 面向对象

优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活，更加易于维护。

缺点：性能比面向对象低

### 2.重载和重写的区别

重载：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。

重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类；如果父类方法访问修饰符为private则子类中就不是重写。

### 3.构造器Constructor是否可以被override

构造器Constructor不能被继承，因此不能重写overriding，但可以被重载overloading

### 4.访问控制符public,protected,private以及默认的区别

| 控制符    | 作用范围                         |
| --------- | -------------------------------- |
| private   | 只有在本类中才能访问             |
| public    | 在任何地方都能访问               |
| protected | 在同包内的类以及包外的子类能访问 |
| 默认不写  | 在同包内能访问                   |

### 5.是否可以继承string类

String类是final类故不可以继承，一切由final修饰过的都不能继承

#### 为什么string是不可变的

因为String对象缓存在String池中。由于缓存的字符串在多个客户之间共享，因此始终存在风险，其中一个客户的操作会影响所有其他用户。例如，如果一段代码将String “Test”的值更改为“TEST”，则其他所有客户也将看到该值，由于String对象的缓存性能是很重要的一方面，因此通过使String不可变来避免这种风险。

同时，String是final的，因此没有人可以通过扩展和覆盖行为来破坏String类的不可变性、缓存、散列值的计算等。String类不可变的另一个原因可能是由于HashMap。

由于把字符串作为HashMap键很受欢迎。对于键值来说，重要的是它们是不可变的，以便用它们检索存储在HashMap中的值对象。由于HashMap的工作原理是散列，因此需要具有不同的值才能正常运行。如果插入后修改了String的内容，可变的String将在插入和检索时生成两个不同的哈希码，可能会丢失Map中的值对象。

#### final关键字

final关键字主要用在三个地方：变量，方法，类

1. 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改，如果是引用类型的变量，则在对其初始化之后不能再让其指向另一个对象。
2. 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法
3. 使用final方法的原因有两个：第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在Java版本已经不需要使用final方进行这些优化了）。类中所有的option方法都隐式地指定为final

### 6.hashCode和equals的区别和联系

#### hashcode和equals

hashcode的作用是获取哈希吗，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashcode定义在jdk的Object.java中，这就意味着java中的任何类都包含有hashcode()函数。另外要注意的是：Object的hashCode方法是本地方法，也就是用c语言或c++实现的，该方法通常用来将对象的内存地址转换为整数之后返回。

```java
public native int hashCode();
```

#### 为什么要有hashCode

当你把对象加入hashSet时，hashSet会先计算对象的hashCode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashCode值进行比较，如果没有相符的hashCode，HashSet会假设对象没有重复出现。但是如果发现有相同的hashCode值的对象，这时就会调用equals方法来检查hashCode相同的对象是否真的相同。如果相同hashSet就不会让其加入操作成功。如果不同，就会重新散列到其他位置。

#### hashCode和equals的相关规定

1. 如果两个对象相等，则他们的hashCode一定相等
2. 两个对象相等，对他们调用equals方法返回true
3. 两个对象有相同的hashCode值也不一定相等
4. 因此equals被覆盖过，hashCode也必须被覆盖
5. hashCode的默认行为是对堆上的对象产生特殊值。如果没有重写则两个class对象的hashCode一定不相等，即使内容相等。

### 7.String、StringBuffer和StringBuilder的区别

#### 可变性

简单来说：String类中使用final关键字字符数组保存字符串，private final char value[]，所以String对象是不可变的，而StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串char[] value。但是没有使用final关键字修饰，所以这两种对象都是可变的。

#### 线程安全性
String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。
#### 性能
每次对String 类型进行改变的时候，都会生成一个新的String 对象，然后将指针指向新的String 对象。StringBuffer每次都会对
StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用
StirngBuilder 相比使用
StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

#### 总结

1. 操作少量的数据用string
2. 单线程在字符串缓冲区下操作大量数据用StringBuilder
3. 多线程在字符串缓冲区下操作大量数据用StringBuffer

### 8.==和equals

==：它的作用是判断两个对象的地址是不是相等，即判断两个对象是不是同一个对象。（基本数据类型\==比较的是值，引用数据类型\==比较的是内存地址）

equals()：它的作用也是判断两个对象是否相等，但它一般有两种使用情况

- 类没有覆盖equals()方法，则通过equals()比较该类的两个对象时，等价于







### 9.接口和抽象类的区别

语法层次
抽象类和接口分别给出了不同的语法定义。
设计层次
抽象层次不同，抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。
跨域不同
抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在"is-a"
关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的，仅仅是实现了接口定义的契约而已，"like-a"的关系。

1. 接口的默认方法是public，所有方法在接口中不能有实现（Java8开始接口方法可以有默认实现），抽象类可以有非抽象方法
2. 接口中的实例变量默认是final类型的，而抽象类中则不一定
3. 一个类可以实现多个接口，但最多只能实现一个抽象类
4. 一个类实现接口的话要实现接口的所有方法，而抽象类不一定
5. 接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象，从设计层面来说，抽象是对类的抽象，是一种模块设计，接口是行为的抽象，是一种行为的规范。

** 注意：在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，必须重写，不然会报错。



### 10.什么是泛型、为什么要使用以及泛型擦除

泛型，即“参数化类型”。
创建集合时就指定集合元素的类型，该集合只能保存其指定类型的元素，避免使用强制类型转换。
Java编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理时被擦除，这个过程即类型擦除。泛型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码。
类型擦除的主要过程如下：
1）将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。
2）移除所有的类型参数。



### 11.Error、Exception区别

Error类和Exception类的父类都是throwable类，他们的区别是：
Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。
Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。

- throw和throws有什么不同
- throw是语句抛出一个异常，throws是方法可能抛出异常的声明。

在一下四种特殊情况下，finally块不会执行：

1. 在finally语句块中发生了异常
2. 在前面的代码中用了System.exit()退出程序
3. 程序所在的线程死亡
4. 关闭CPU

### 12.Java中如何实现代理机制(JDK、CGLIB)

JDK动态代理：代理类和目标类实现了共同的接口，用到InvocationHandler接口。
CGLIB动态代理：代理类是目标类的子类，用到MethodInterceptor接口。

动态代理：是使用反射和字节码的技术，在运行期创建指定接口或类的子类（动态代理）以及其实例对象的技术，通过这个技术可以无侵入性的为代理进行增强

#### 实现的两种方式

1. JDK原生动态代理
2. CGLB动态代理

##### JDK原生动态代理

Proxy：Proxy是所有动态代理的父类，它提供一个静态方法(new ProxyInstance())来创建动态代理的class对象和实例；

InvocationHandler：每个动态代理实例都有一个关联的InvocationHandler。在代理实例上调用方法时，方法调用被转发到InvocationHandler的invoke方法；

##### CGLIB动态代理

CGLIB（Code Generation Library）是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过集成方式实现代理；

Enhancer：来指定要代理的目标对象、实际处理代理逻辑的对象，最终通过调用create()方法得到代理对象，对这个对象所有非final方法的调用都会转发给MethodInterceptor；

MethodInterceptor：动态代理对象的方法都会转发到intercept方法进行增强；



> JDK原生动态代理是Java原生支持的，不需要任何外部依赖，但是他只能基于接口进行代理
>
> CGLIB通过继承的方式进行代理，无论目标对象有没有实现接口都可以代理，但是无法处理final的情况





- length()和length有什么不同

  - length是针对数组的属性，查看数组的长度
  - length()是针对字符串的方法，查看字符串的长度
  
  

**.super.getClass()方法调用？**

下面程序的输出结果是多少？

```java
import java.util.Date;
public class Test extends Date{
    public static void main(String[] args) { new Test().test(); }
    public void test(){
        System.out.println(super.getClass().getName()); 
    }
}
```

答：结果是Test。

原因：在test方法中，直接调用getClass().getName()方法，返回的是Test类名

由于getClass()在Object类中定义成了final，子类不能覆盖该方法，所以，在test方法中调用getClass().getName()方法，其实就是在调用从父类继承的getClass()方法，等效于调用super.getClass().getName()方法，所以，super.getClass().getName()方法返回的也应该是Test。

如果想得到父类的名称，调用：getClass().getSuperClass().getName();

