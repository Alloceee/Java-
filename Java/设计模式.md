**77.设计模式**

参考文章：[http://www.cnblogs.com/beijiguangyong/archive/2010/11/15/2302807.html#_Toc281750445。](https://link.zhihu.com/?target=http%3A//www.cnblogs.com/beijiguangyong/archive/2010/11/15/2302807.html%23_Toc281750445%E3%80%82)

**78.设计模式的六大原则**

参考文章[http://www.uml.org.cn/sjms/201211023.asp。](https://link.zhihu.com/?target=http%3A//www.uml.org.cn/sjms/201211023.asp%E3%80%82)



# 工厂模式

### 简单工厂



### 抽象工厂

1. 一个工厂创建类，用来创建具体的工厂类

```java
public class FactoryBuilder {
    public static AbstractContractorFactory getFactory(String name){
        if ("DrillingWorker".equalsIgnoreCase(name)) {
          return new DrillingFactory();
        }else if ("BricksWorker".equalsIgnoreCase(name)) {
                return new BricksFactory();
         }
        return null;
    }
}
```

2. 具体的工厂类继承同一个抽象的工厂，抽象工厂提供所有获取对象接口的方法

```java
public abstract class AbstractContractorFactory {

    public  DrillingWorker getDrilling(String grade){
        return null;
    };

    public  MovingBricksWorker getBricks(String grade){
        return null;
    };
}

```

3. 具体工厂实现对应的方法，根据参数，具体实现获取对应对象的方法

```java
public class BricksFactory extends AbstractContractorFactory{
    @Override
    public MovingBricksWorker getBricks(String grade) {
        if("高级".equalsIgnoreCase(grade)){
            return new SeniorMovingBricksWorker();
        }else if("中级".equalsIgnoreCase(grade)){
            return new LXMovingBricksWorker();
        }else if("低级".equalsIgnoreCase(grade)){
            return new NormalMovingBricksWorker();
        }
        return null;
    }
}
public class DrillingFactory extends AbstractContractorFactory {

    @Override
    public DrillingWorker getDrilling(String grade) {
        if("高级".equalsIgnoreCase(grade)){
           return new SeniorDrillingWorker();
        }else if("中级".equalsIgnoreCase(grade)){
           return new LXDrillingWorker();
        }else if("低级".equalsIgnoreCase(grade)){
           return new NormalDrillingWorder();
        }
        return null;
    }
}
```

4. 对象接口提供对象实现方法

```java
public interface DrillingWorker {
    //钻井工人钻井
    void drilling();
}
```

```java
public interface MovingBricksWorker {
    //搬砖工人搬砖
    void movingBricks();
}

```

5. 对象继承对象接口，具体实现方法

```java
public class LXDrillingWorker implements DrillingWorker {
    @Override
    public void drilling() {
        System.out.println("我是蓝翔钻井工人，我一次100米呢");
    }
}
```

```java
public class LXMovingBricksWorker implements MovingBricksWorker {
    @Override
    public void movingBricks() {
        System.out.println("我是蓝翔搬砖的，只要600");
    }
}
```

#### 抽象工厂和工厂方法模式的区别

##### 定义区别：

- 工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类

- 抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类

- 区别在于产品，如果产品单一，最合适用工厂模式，但是如果有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。再通俗深化理解下：工厂模式针对的是一个产品等级结构 ，抽象工厂模式针对的是面向多个产品等级结构的。

- 再来看看工厂方法模式与抽象工厂模式对比：
  ![img](C:\Users\AlmostLover\Desktop\MarkDown笔记\Java\1251936-20181116234719686-423732240.png)

  ##### 举个例子说明下：

- 用种蔬菜的例子来说明事实，最初的时候，由于规模小，只种植一种蔬菜，根菜类蔬菜，这个时候由于种植方式比较简单，采用简单工厂模式即可，主要目的是让工人轻松，下达工厂种植即可，但是随着种植厂的发展以及市场的需求，要增加一种蔬菜类型种植了，茎菜，由于茎菜与根菜种植方式不一致，就需要两个专门的种植工厂来进行管理，那么久采用工厂模式来管理，一个工厂负责一种作物的种植，这个时候产品可以理解为仍然在一个层次。但是随着科技的发展，我们逐步要种植转基因与非转基因食品了，在以前的蔬菜种类上又增加了一个层次，这个时候无法将其作为一个层次来解决，所以必须采用抽象工厂的方式来解决。我用UML图表示三种结构：
  ![img](C:\Users\AlmostLover\Desktop\MarkDown笔记\Java\1251936-20181116234906675-1640401539.png)
  ![img](C:\Users\AlmostLover\Desktop\MarkDown笔记\Java\1251936-20181116235024437-729359950.png)
  ![img](C:\Users\AlmostLover\Desktop\MarkDown笔记\Java\1251936-20181116235043231-1254529744.png)

- 上面的UML图很明显的就看出来了，抽象工厂可以创建多个产品类对象，如在种菜工厂中，有种根菜，种茎菜。工厂模式与抽象工厂模式以及简单工厂模式只有在具体应用的时候，分析具体的产品层级，然后选择相应的设计模式。

- 而在每一个层次，种菜工人所关心的对象也不一样，在简单工厂模式下，工人要想到种植萝卜还是白菜，在工厂模式下，工人想到是种植根菜还是茎菜，而在抽象工厂模式下，则关心种植基因菜还是非基因菜





# 组合模式

任何复杂的结构，都是由多个部分结构经过一定的层次组合而来。





# 单例模式

单例模式就是只能创建一次对象，不能通过New创建对象，因此构造函数私有化

懒汉式：上来直接创建对象

```java
public class Singleton1 {
    //直接创建对象
    public static Singleton1 instance = new Singleton1();

    //私有化构造函数
    private Singleton1() {
    }

    //返回对象实例
    public static Singleton1 getInstance() {
        return instance;
    }
}
```

饿汉式

```java
public class Singleton2 {
    //声明变量
    private static volatile Singleton2 singleton2 = null;

    //私有构造函数
    private Singleton2() {
    }

    //提供对外方法

    public static Singleton2 getSingleton2() {
        if (singleton2 == null) {
            synchronized (Singleton2.class) {
                if (singleton2 == null) {
                    singleton2 = new Singleton2();
                }
            }
        }
        return singleton2;
    }
}
```

双重加锁机制

```java 
/**
 * 双重查锁机制
 */
public class Singleton3 {
    private static Singleton3 instance = null;

    private Singleton3(){

    }

    public static Singleton3 getInstance(){
        if(instance==null){
            synchronized (Singleton3.class){
                if(instance==null){
                    instance = new Singleton3();
                }
            }
        }
        return instance;
    }

    //枚举单例
    //静态内部类
}
```

静态内部类

```java
/**
 * 静态内部类单例
 */
public class StaticInner {
    private static StaticInner instance;
    public static StaticInner getInstance(){
        return SingletonHolder.STATIC_INNER;
    }

    private static class SingletonHolder {
        private static final StaticInner STATIC_INNER = new StaticInner();
    }
}
```









# 建造者模式（Bilder）



# 原型模式



# 适配器模式

一般是抽象类



# 组合模式



# 装饰者模式

装饰者模式（Decorator Pattern）也称为包装模式（Wrapper Pattern），以透明动态的方式来动态扩展对象的功能，也是继承关系的一种代替方案。



优点：

相对于继承，装饰器模式灵活性更强

![img](https:////upload-images.jianshu.io/upload_images/595349-169201462ebfa09f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/852/format/webp)

装饰模式.png

- Component：抽象组件（可以是抽象类或者接口），被装饰的原始对象
- ConcreteComponent：具体实现类，被装饰的具体对象
- Decorator：抽象装饰者，职责就是为了装饰我们的组件对象，内部一定要有一个指向组件对象的引用
- ConcreteDecoratorA：装饰者具体实现类，只对抽象装饰者做出具体实现
- ConcreteDecoratorB：同上

### android中的装饰者模式

在`android`中，`Context`就是典型的**装饰者模式**，`Context`是抽象类，真实的功能实现实在`ComtextImpl`中完成，`ComtextImpl`就是`Context`的实现类；然后看源码会发现`Activity`是继承于`ContextThemeWrapper`而不是直接继承于`Context`。其中`ContextThemeWrapper` 继承于`ContextWrapper`，而`ContextWrapper`继承于`Context`。这里就可以看出来一点**装饰者模式**了，其中装饰者所调用的方法就是`startActivity`方法，在`ContextWrapper`中会发现`startActivity`方法调用了`ComtextImpl`中对应的方法，实质上`ContextWrapper`中所有方法都仅仅是调用了`ComtextImpl`中的方法，这就和装饰者模式基本就对应上了。7

### 优点

- 装饰者模式与继承关系的目的都是要扩展对象的功能，但是装饰者模式可以提供比继承更多的灵活性。
- 通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。

### 缺点

- 这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。
- 装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。
- 装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变`Component`接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。

### 与代理模式的区别

其实装饰者模式和代理模式很像，但是两者的目的不尽相同。装饰者模式是以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案；而代理模式则是一个给对象提供一个代理对象，并由代理对象来控制对原有对象的引用。

装饰者模式为本装饰的对象进行功能扩展；代理模式对代理对象进行控制，但不做功能扩展

使用举例：

IO中输入流和输出流的设计

对网络爬虫的自定义增强，可增强的功能包括：多线程能力、缓存、自动生成报表、黑白名单、random触发等

mybatis的缓存组件

缓存装饰器解读

|      |      |
| ---- | ---- |
|      |      |
|      |      |
|      |      |

锁粒度的问题 醋粒度锁

# 代理模式

- ##### 代理模式：接口+真实实现类+代理类

1. 接口

```java
public interface Payment {
    void pay();
}
```

2. 实现类

```java
public class AliPayment implements Payment {
    private Payment payment;
    public AliPayment(Payment payment){
        this.payment = payment;
    }
    @Override
    public void pay() {
        beforePay();
        payment.pay();
        afterPay();
    }
    private void beforePay(){
        System.out.println("先转钱");
    }

    private void afterPay(){
        System.out.println("转钱到账");
    }
}

```

3. 真实实现类

```java
public class RealPayment implements Payment {

    @Override
    public void pay() {
        System.out.println("我是支付环节");
    }
}

```

4. 代理测试类

```java
public class ProxyText {
    public static void main(String[] args) {
        AliPayment proxy = new AliPayment(new RealPayment());
        proxy.pay();
    }
}
```

举例说明：代理可以对实现类进行统一的管理，如在调用具体实现类之前，需要打印日志等信息，这样我们只需要添加一个代理类，在代理类中添加打印日志的功能，然后调用实现类，这样就避免了修改具体实现类。满足我们所说的开闭原则。但是如果想让每个实现类都添加打印日志的功能的话，就需要添加多个代理类，以及代理类中各个方法都需要添加打印日志功能（如上的代理方法中删除，修改，以及查询都需要添加上打印日志的功能）

即静态代理类只能为特定的接口(Service)服务。如想要为多个接口服务则需要建立很多个代理类。

**引入动态代理：**

 

根据如上的介绍，你会发现每个代理类只能为一个接口服务，这样程序开发中必然会产生许多的代理类

所以我们就会想办法可以通过一个代理类完成全部的代理功能，那么我们就需要用动态代理

 

在上面的示例中，一个代理只能代理一种类型，而且是在编译器就已经确定被代理的对象。而动态代理是在运行时，通过反射机制实现动态代理，并且能够代理各种类型的对象

 

在Java中要想实现动态代理机制，需要java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy 类的支持

动态代理优点：

 

动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。而且动态代理的应用使我们的类职责更加单一，复用性更强

 

### 总结：

其实所谓代理，就是一个人或者一个机构代表另一个人或者另一个机构采取行动。在一些情况下，一个客户不想或者不能够直接引用一个对象，而代理对象可以在客户端和目标对象之前起到中介的作用。

代理对象就是把被代理对象包装一层，在其内部做一些额外的工作，比如用户需要上facebook,而普通网络无法直接访问，网络代理帮助用户先翻墙，然后再访问facebook。这就是代理的作用了。

*纵观态代理与动态代理，它们都能实现相同的功能，而我们看从静态代理到动态代理的这个过程，我们会发现其实动态代理只是对类做了进一步抽象和封装，使其复用性和易用性得到进一步提升而这不仅仅符合了面向对象的设计理念，其中还有**AOP**的身影，这也提供给我们对类抽象的一种参考。关于动态代理与**AOP**的关系，个人觉得**AOP**是一种思想，而动态代理是一种**AOP**思想的实现！*



# 观察者模式



# 订阅者和发布者模式



# 策略模式



# 模板模式



# 访问者模式



- 手写一个单例模式（几种不同实现方法）
- 某个常见的设计模式在你的项目中是如何体现的
- 抽象工厂和工厂方法模式的区别
- 工厂模式的思想
- 代理模式，观察者模式