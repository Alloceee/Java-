一个对象是否需要是线程安全的，取决于他是否被多个线程访问。这指的是在程序总访问对象的方式，而不是对象要实现的功能。要使得对象是安全的，需要采取同步机制来协同对对象可变状态的访问。

### synchronized

JAVA中同步机制主要是关键字synchronized，他提供了一种独占的加锁方式，但“同步”这个术语还包括volatile类型的变量，显式锁以及原子变量。

> 线程安全的程序不一定全部由线程安全类构成。
>
> 全部由线程安全类构成的程序也不一定是安全的。
>
> 线程安全的程序也可以用包含非线程安全的类。

无状态对象一定是线程安全的。

大多数的Servlet都是无状态的，从而极大的降低了在实现Servlet线程安全性时的复杂性，但servlet在处理请求时需要保存一些信息，线程安全性才会成为一个问题。

++a操作并非一个原子操作，是一个“读取 - 修改 - 写入”的操作序列，并且其结果依赖于之前的状态。

原子操作是指，对于访问同一个状态的所有操作，（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。

### 竞态条件

当某个计算的正确定取决于多个线程的交替执行时序时，那么就会发生竞态条件。换句话说，就是正确的结果要取决于运气。

#### 示例：延迟初始化中的竞态条件

使用“先检查后执行”的一种常见情况就是延迟初始化。延迟初始化的目的是将对象的初始化操作延迟到实际被使用时才进行，同时要确保只被初始化一次。

### 内置锁

Java提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block）

同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的synchronized方法以Class对象作为锁。

```java
synchronized(lock){
    //访问或修改由该锁保护的共享状态
}
```

> 进入同步代码块之间会自动获得锁，退出代码块时自动释放锁，无论是正常路径退出，还是通过从代码块中抛出异常退出，获得内置锁的唯一途径就是进入这个锁保护的同步代码块或方法。



### 用锁保护状态

对象的内置锁与其状态之间没有任何关联。虽然大多数类都将内置锁用作一种有效的加锁机制，但对象的域并不一定要通过内置锁保护。当获取与对象关联的锁时，并不能阻止其他线程访问该对象，某个线程在获得对象的锁之后，只能阻止其他线程获得同一个锁。之所以每个对象都有一个内置锁，只是为了避免显式地创建锁对象，你需要自行构建加锁协议或者同步策略来实现对共享状态的安全访问，并且在程序中至始至终使用他们。

一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问，在许多线程安全类中都是用了这种模式，例如vector和其他的同步集合类。

> 不能过度的加synchronized同步锁，会导致活跃性（Liveness）问题或性能（Performance）问题



### JDK1.6之后的synchronized关键字底层做了哪些优化

JDK1.6对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销

锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级，注意锁可以升级但是不可以降级，这种策略是为了提高获得锁和释放锁的效率。



### synchronized和Reentrantlock的区别

#### Reentrantlock(再入锁)

位于java.util.concurrent.locks包

和CountDownLatch、FutureTask、Semaphore一样基于AQS实现

#### synchronized

synchronized关键字解决的是多线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

#### 1.两者都是可重入锁

两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可重入锁的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以到等到锁的计数器下降为0时才能释放锁。

#### 2.synchronized依赖于JVM而ReenTrantLock依赖于API

synchronized是依赖于JVM实现的，优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock是JDK层面实现的（也就是API层面，需要lock()和unlock()方法配合try/finally语句块来实现），所以我们可以通过查看它的源码来看如何实现。

#### 3.ReenTrantLock比synchronized增加了一些高级功能

- 等待可中断：通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情
- 可实现公平锁：可以指定是公平锁还是非公平锁，而synchronized只能是非公平锁，所谓的非公平锁就是先等待的线程先获得锁。ReenTrantLock默认是非公平的，可以通过ReenTrantLock类的ReenTrantLock(boolean fair)构造方法来指定是否是公平的。
- 可实现选择性通知（锁可以绑定多个条件）：需要借助Condition接口和newCondition()方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能，也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器）。**线程对象可以注册在指定的Condition中，从而可以有选择性地进行线程通知，在调度线程上更加灵活。在使用notify/notifyAll()方法进行通知时，被通知的线程是由JVM选择的，用ReenTrantLock类结合Condition实例可以实现“选择性通知”**。Condition实例的signalAll()方法只会唤醒注册在该Condition实例中的所有等待线程。





### synchronized和lock的区别



### synchronized和volatile关键字的作用

#### Volatile和synchronized的意义

- 一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，就具备了两层语义：
  1. 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的
  2. 禁止进行指令重排序
- volatile本质是在告诉JVM当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；
- synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。

#### volatile和synchronized的区别

1. volatile仅能使用在变量级别，synchronized则可以使用在变量、方法和类级别；
2. volatile仅能实现变量的修改可见性，并不能保证原子性；synchronized则可以保证变量修改的可见性和原子性；
3. volatile不能造成线程阻塞，synchronized可能会造成线程阻塞；
4. volatile标记的变量不会被编辑器优化，synchronized标记的变量可以被编译器优化



### 可重入锁和非可重入锁的区别



### 多线程是解决什么问题的



### Reentrantlock源码、设计原理、整体过程