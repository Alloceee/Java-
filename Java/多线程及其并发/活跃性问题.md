# 死锁

如何避免死锁

- 1.加锁顺序（线程按照一定顺序加锁）
- 2.加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）

死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。
产生死锁的原因：
一.因为系统资源不足。
二.进程运行推进的顺序不合适。
三.资源分配不当。

**33.如何才能产生死锁**

产生死锁的四个必要条件：
一.互斥条件：所谓互斥就是进程在某一时间内独占资源。
二.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
三.不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。
四.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

**34.死锁的预防**

打破产生死锁的四个必要条件中的一个或几个，保证系统不会进入死锁状态。
一.打破互斥条件。即允许进程同时访问某些资源。但是，有的资源是不允许被同时访问的，像打印机等等，这是由资源本身的属性所决定的。所以，这种办法并无实用价值。
二.打破不可抢占条件。即允许进程强行从占有者那里夺取某些资源。就是说，当一个进程已占有了某些资源，它又申请新的资源，但不能立即被满足时，它必须释放所占有的全部资源，以后再重新申请。它所释放的资源可以分配给其它进程。这就相当于该进程占有的资源被隐蔽地强占了。这种预防死锁的方法实现起来困难，会降低系统性能。
三.打破占有且申请条件。可以实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源。如果某个进程所需的全部资源得不到满足，则不分配任何资源，此进程暂不运行。只有当系统能够满足当前进程的全部资源需求时，才一次性地将所申请的资源全部分配给该进程。由于运行的进程已占有了它所需的全部资源，所以不会发生占有资源又申请资源的现象，因此不会发生死锁。
四.打破循环等待条件，实行资源有序分配策略。采用这种策略，即把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成环路。所有进程对资源的请求必须严格按资源序号递增的顺序提出。进程占用了小号资源，才能申请大号资源，就不会产生环路，从而预防了死锁。

# 饥饿



# 活锁

## **什么是线程饿死，什么是活锁？**

**什么是线程饿死，什么是活锁？**
**线程饿死**和活锁虽然不像死锁一样是常见的问题，但是对于并发编程的设计者来说就像一次邂逅一样。
当所有线程阻塞，或者由于需要的资源无效而不能处理，不存在非阻塞线程使资源可用。
JavaAPI 中线程活锁可能发生在以下情形：
当所有线程在程序中执行 Object.wait (0)，参数为 0 的 wait 方法。
程序将发生活锁直到在相应的对象上有线程调用 Object.notify ()或者 Object.notifyAll ()。
当所有线程卡在无限循环中。

**多线程中的忙循环是什么?**
**忙循环**就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存。
在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。

