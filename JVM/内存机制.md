# JVM内存结构和内存分配

### JVM内存结构模型

- #### heap和stack的区别
  
  - ##### 申请方式
    
    - stack：由系统自动分配。例如，声明在函数中一个局部变量int b；系统自动在栈中为b开辟空间
    - heap：需要程序员自己申请，并指明大小。在c中malloc函数，对于java需要手动new Object()的形式开辟
  - ##### 申请后系统的响应
    
    - stack：只要栈的剩余空间大于所需空间，系统将为程序提供内存，否则将报错异常提示栈溢出
    - heap：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆栈点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。
  - ##### 申请大小的限制
    
    - stack：栈是向低地址扩展的数据结构，是一块连续的内存的区域。
  - ##### 申请效率的比较
    
    - stack：由系统自动分配，速度较快，但程序员是无法控制的
    - heap：由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来方便
  - ##### heap和stack中的存储内容
    
    - stack：在函数调用时，
    - heap：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排
  - 数据结构层面的区别
  - java中堆栈的应用
  
- #### 解释内存中的栈（Stack）、堆（heap）和方法区（method area）的用法
  
  - 通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都是JVM中的栈空间
  - 通过new关键字和构造器创建的对象放在堆空间，堆是垃圾回收器管理的主要区域，由于现在的垃圾回收器都采用分代收集算法，所以堆空间还可以
  - 方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据
  - 程序中的字面量（literal）如直接书写的“100”、“hello”和常量都是放在常量池中，常量池是方法区的一部分。
  - 栈空间操作最快，但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM启动参数进行调整
  - 栈空间用完引发StackOverFlowError，堆和常量池空间不足引发OutOfMemoryError
  - String str = new String("Hello") str对象引用存放栈中，字符串对象存放堆中，而"Hello"这个字面量放在方法区
  
- #### ClassLoader（类加载器）
  
  - ##### 什么是ClassLoader
    
    - ClassLoader在Java中起非常重要的作用，它主要工作在class装载的加载阶段，其主要作用是从系统外部获得class二进制数据流。它是Java的核心组件，所有class都是由ClassLoader进行加载的，ClassLoader负责通过将class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行链接、初始化等操作。
  - ##### ClassLoader的种类
    
    - BootstrapClassLoader（根类加载器）：C++编写，加载核心库java.*
    - ExtClassLoader（拓展类加载器）：Java编写，加载扩展库javax.*，加载jar包，--加载位置：jre\lib\ext中
    - AppClassLoader（系统（应用）类加载器）：Java编写，加载程序所在目录的类和jar包，--加载位置 ：classpath中
    - 用户自定义ClassLoader：Java编写，定制化加载，必须extends ClassLoader
  - ##### ClassLoader的双亲委派机制
    
    - 自底向上检查类是否已经加载
    - 自顶向下尝试加载类
  - ##### 为什么使用双亲委派机制去加载类
    
    - 避免多份同样字节码的加载
  - ##### 类的加载方式
    
    - 隐式加载：new
      - 无需调用newInstance()方法即可获得实例。
    - 显式加载：loadClass、forName等
      - new支持带参数的构造器生成对象实例，class对象的newInstance方法不支持传入参数，需要通过反射调用构造器的newInstance()方法才能支持参数
  - ##### loadClass和forName的区别
    
    - 类的装载过程
      - 加载
        - 通过classLoader加载class文件字节码生成对象
      - 链接
        - 检验：检验加载class的正确性和安全性
        - 准备：为类变量分配存储空间并设置类变量初始值
        - 解析：JVM将常量池内的符号引用转换为直接引用
    - class.forName得到的class是已经初始化完成的
    - ClassLoader.loadClass得到的class是还没有链接的
      - static{} 静态代码块，类初始化时执行
      - 使用loadClass时静态代码块中的代码不会执行
      - 使用forName时静态代码块中的代码会执行，因为类已经进行初始化操作
  - ##### loadClass应用场景
  
- #### 类什么时候被初始化
  
  - 创建类的实例，也就是new一个对象
  - 访问某个类或接口的静态变量，或者对该静态变量赋值
  - 调用类的静态方法
  - 反射（Class.forName("com.lyj.load")）
  - 初始化一个类的子类（会首先初始化子类的父类）
  - JVM启动时标明的启动类，即文件名和类名相同的那个类
  
- #### 类的初始化步骤
  
  - 如果这个类还没有被加载和链接，那先进行加载和链接
  - 假如这个类存在直接父类，并且这个类还没有被初始化（注意：在一个类加载器中，类只能初始化一次），那就初始化直接的父类（不适用与接口）
  - 假如类中存在初始化语句（如static变量和static块），那就依次执行这个初始化语句
  
- #### JVM何时结束生命周期

  - 正常执行完毕程序
  - 执行了System.exit()
  - 程序执行期间发生了异常或者错误而终止
  - 由于底层操作系统出错，导致虚拟机结束进程

- ### 内存泄露

  内存泄露一般可以理解为系统资源（各方面的资源，堆、栈、线程等）在错误使用的情况下，导致使用完毕的资源无法回收（或没有回收），从而导致新的资源请求无法完成，引起系统错误。

  整个JVM内存打下=年轻代大小+老年代大小+持久代大小

- ### 内存溢出的原因

  - 内存中加载的数据量过于庞大，如一次从数据库中取出过多的数据
  - 集合类中有对对象的引用，使用完后未清空，使得JVM不能回收
  - 代码中存在死循环或循环产生过多重复的对象实体
  - 使用的第三方软件中的bug
  - 启动参数内存值设定的过小

**43.内存溢出和内存泄漏的区别**

内存溢出是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory。
内存泄漏是指分配出去的内存不再使用，但是无法回收。

**44.Java内存模型及各个区域的OOM，如何重现OOM**

这部分内容很重要，详细阅读《深入理解Java虚拟机》，也可以详细阅读这篇文章

**45.出现OOM如何解决**

一. 可通过命令定期抓取heap dump或者启动参数OOM时自动抓取heap dump文件。
二. 通过对比多个heap dump，以及heap dump的内容，分析代码找出内存占用最多的地方。
三. 分析占用的内存对象，是否是因为错误导致的内存未及时释放，或者数据过多导致的内存溢出。

**48.Java类加载器及如何加载类(双亲委派)**

阅读文章：
[https://www.ibm.com/developerworks/cn/java/j-lo-classloader/（推荐）](https://link.zhihu.com/?target=https%3A//www.ibm.com/developerworks/cn/java/j-lo-classloader/%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89)
[深入理解Java类加载器(1)：Java类加载原理解析 - Jack Zhou的专栏 - 博客频道 - CSDN.NET](https://link.zhihu.com/?target=http%3A//blog.csdn.net/zhoudaxia/article/details/35824249)

### 分类

1. 老年代堆空间被占满

```java
java.lang.OutOfMemoryError:Java heap space
```

这是最典型的内存泄露方式，简单说就是所有堆空间都被无法回收的垃圾对象占满，虚拟机无法再在分配新空间。这种情况一般来说是因为内存泄露或者内存不足造成的。某些情况因为长期的无法释放对象，运行时间长了以后导致数量增多，从而导致内存泄露。另外一种就是因为系统的原因，大并发加上大对象，Survivor Space区域内存不够，大量的对象进入到了老年代，然而老年代的内存也不足时，从而产生了Full GC，但是这个时候Full GC也无法回收，这个时候就会产生此错误。

> 解决方案：
>
> 代码内的内存泄露可以通过一些分析工具进行分析，然后找出泄露点进行改善
>
> 第二种原因导致的OutOfMemoryError可以通过代码优化和增加Survivor Space扥方式去优化

2. 持久代被占满

```java
java.lang.OutOfMemoryError:PermGen space
```

Perm空间被占满。无法为新的class分配存储空间而引发的异常。这个异常以前是没有的，但是在Java反射大量使用的今天这个异常比较常见了。主要原因就是大量动态反射的类不断被加载，最终导致Perm区被占满。

> 解决方法：
>
> 增加持久代的空间XX:MaxPermSize=100M
>
> 如果有自定义类加载器的需要排查下自己的代码问题

3. 堆栈溢出

```java
java.lang.StackOverflowError
```

一般就是递归没返回，或者循环调用造成的

4. 线程堆栈满

```java
Fetal:Stack size too small
```

Java中一个线程的空间大小是有限制的。JDK5.0以后这个值是1M。与这个线程相关的数据将会保存在其中。但是当线程空间满了以后，将会出现上面异常。

> 解决方法：
>
> 增加线程栈大小 -Xss2m
>
> 但这个配置无法解决根本问题，还是看代码部分是否有造成泄漏的部分

5. 系统内存被占满

```java
java.lang.OutOfMemoryError:unable to create new native thread
```

这个异常是由于操作系统没有足够的资源来产生这个线程造成的。系统创建线程时，除了要在Java堆中分配内存外，操作系统本身也需要分配资源来创建线程。因此，当线程数量大到一定程度后，堆中或许还有空间，但是操作系统分配不出资源来了，就出现这个异常。分配给Java虚拟机的内存越多，系统剩余的资源就越少，因此，当系统内存固定时，分配给Java虚拟机的内存越多，那么，系统总共能够产生的线程也就越少，两者成反比关系。同时，可以通过修改-Xss来减少分配给单个线程的空间，也可以增加系统总共内生产的线程数。

> 解决方案：
>
> 重新设计系统减少线程数量
>
> 线程数量不能减少的情况下，通过-Xss减少单个线程的大小，以便能产生更多的线程

**Java内存模型**规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了：
线程内的代码能够按先后顺序执行，这被称为程序次序规则。
对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。
前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。
一个线程内的任何操作必需在这个线程的start()调用之后，也叫作线程启动规则。
一个线程的所有操作都会在线程终止之前，线程终止规则。
一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。
可传递性