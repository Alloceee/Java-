# JVM垃圾回收机制和常见算法

- ### 对象被判定为垃圾的标准
  
  - #### 没有被其他对象所引用
    
    - ##### 引用计数算法
      
      - 通过判断对象的引用数量来决定对象是否可以被回收
      - 每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1
      - 任何引用计数为0的对象实例可以被当做垃圾收集
      - 优点：执行效率高，程序执行受影响较小
      - 缺点：无法检测出循环引用的情况，导致内存泄露（如父对象引用子对象，子对象也引用父对象）
      - 不采用此方法
    - ##### 可达性分析算法
      
      - 通过判断对象的引用链是否可达来决定对象是否可以被回收
      - 从GC Root Set开始遍历，判断对象是否可达
      - 可以作为GC Root的对象
        - 虚拟机栈中引用的对象（栈帧中的本地变量表）
        - 方法区中的常量引用的对象
        - 方法区中的类静态属性引用的对象
        - 本地方法栈中JNI（Native方法）的引用对象
        - 活跃线程的引用对象
    - ##### 标记-清除算法（Mark and Sweep）
      
      - 标记：从根集合进行扫描，对存活的对象进行标记
      - 清除：对堆内存从头到尾进行线性遍历，回收不可达对象内存
      - 缺点：碎片化
    - ##### 复制算法（Copying）
      
      - ###### 过程
        
        - 分为对象面和空闲面
        - 对象在对象面上创建
        - 存活的对象从被对象面复制到空闲面
        - 将对象面所有对象内存清除
      - ###### 优点
        
        - 解决碎片化问题
        - 顺序分配内存，简单高效
        - 适用于对象存活率低的场景，比如年轻代，复制的对象少因此效率高
    - ##### 标记-整理算法（Compacting）
      
      - 标记：从根集合进行扫描，对存活对象进行标记
      - 清除：移动所有存活对象的对象，且按照内存地址次序依次排序，然后将末端内存地址以后的内存全部回收
      - ###### 优点：
        
        - 避免内存的不连续行
        - 不用设置两块内存互换
        - 使用于存活率高的场景，更适合老年代的回收
    - ##### 分代收集算法（Generational Conllector）
      
      - 垃圾回收算法的组合拳
      - 按照对象生命周期的不同划分区域以采用不同的垃圾回收算法
      - 目的：提高JVM的回收率
    - jdk8及其以后的版本，移除永久代，年轻代复制算法，老年代标记-清理算法
  
- ### 名词解释
  
  - #### GC分类
    
    - Minor GC ：发生在年轻代中的垃圾收集工作，采用复制算法，年轻代是几乎所有Java对象出生的地方，及Java对象申请内存以及存放都是在其中进行
    - Full GC : 老年代
    
  - #### 年轻代
    
    -  尽可能快速地收集掉那些生命周期短的对象
    - Eden区：对象创建的起源，对象一创建，首先分配在此区域
    - 两个Survivor区： from区和to区
    - 8:1:1默认比例Eden:from:to
    
  - #### Stop-the-world
    
    - JVM由于要执行GC而停止了应用程序的执行
    - 任何一种GC算法中都会发生
    - 多数GC优化通过减少Stop-the-world发生的时间来提高程序的性能
    
  - #### SafePoint
    
    - 必须要等到Java线程都进入SafePoint的时候JVM Thread才能开始执行GC
    - 分析过程中对象引用关系不会发生变化的点
    - 产生Safepoint的地方：方法调用；循环跳转（循环的末尾）；异常跳转（抛出异常的位置）等
    - 安全点得适中
  
- ### 常见的垃圾回收器
  
  - #### JVM运行模式
    
    - Server：启动较慢，启动完成后比client快，因为启动的是重量级JVM，有更多的优化
    - Client：启动较快，启动的是轻量级的JVM
  - #### 垃圾收集器之间的联系
    
    - ##### Serial收集器（-XX：+UseSerialGC，复制算法）
      
      - 单线程收集，进行垃圾收集时，必须暂停所有工作线程
      - 简单高效，Client模式下默认的年轻代收集器
    - ##### ParNew收集器（-XX:+UseParNewGC，复制算法）
      
      - 多线程收集，其余行为、特点和Serial收集器一样
      - 单核执行效率不如Serial，在多核下执行才有优势
    - ##### Parallel Scavenge收集器（-XX：+UseParallelGC，复制算法）
      
      - 吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）
      - 比起关注用户线程停顿时间，更关注系统的吞吐量
      - 在多核下执行才有优势，Server模式下默认的年轻代收集器
    - ##### CMS收集器(-XX:+UseConcMarkSweepGC，标记-清除算法)
      
      - 初始标记：stop-the-world
      - 并发标记：并发追溯标记，程序不会停顿
      - 并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象
      - 重新标记：暂停虚拟机，扫描CMS堆中的剩余对象
      - 并发清理：清理垃圾对象，程序不会停顿
      - 并发重置：重置CMS收集器的数据结构
  
- ### Java中为什么会有GC机制
  
  - 安全性考虑
  - 减少内存泄露
  - 减少程序员工作量
  
- ### GC主要回收区域
  
  - 方法区和堆
  
- ### GC什么时候回收垃圾
  
  - 对于堆中的对象，主要用可达性分析判断一个对象是否还存在引用，如果该对象没有任何引用就应该被回收，而根据我们实际对引用的不同需求，又分成了4种引用（强引用、软引用、弱引用、虚引用），每种引用的回收机制也是不同的
  - 对于方法区中的常量和类，当一个常量没有任何对象引用它，它就被回收了，而对于类，如果可以判定它为无用类，就可以被回收了
    - 废弃常量的回收，看引用计数，没有对象引用该常量就可以回收
    - 无用类的回收：
      - 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例
      - 加载该类的ClassLoader已经被回收
      - 该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法
  

**47.Java内存管理及回收算法**

阅读这篇文章：[Java 内存区域和GC机制 - Leo Chin - 博客园](https://link.zhihu.com/?target=http%3A//www.cnblogs.com/hnrainll/archive/2013/11/06/3410042.html)

- 如何判断对象是否死亡（两种方法）
- 简单介绍一下强引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）
- 如何判断一个常量是废弃常量
- 如何判断一个类是无用的类
- 垃圾收集有哪些算法，各自的特点
- HotSpot为什么要分为新生代和老年代
- 常见的垃圾回收机制有哪些
- 介绍一下CMS,G1收集器
- Minor Gc和Full Gc有什么不同