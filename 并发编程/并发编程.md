# 并发编程

## 1、线程基础、线程
之间的共享和协作

### 基础概念

- CPU核心数，线程数

核心数:线程数=1:1  ;使用了超线程技术后---> 1:2

- CPU时间片轮转机制

又称RR调度，会导致上下文切换

- 什么是进程和线程

进程：程序运行资源分配的最小单位，进程内部有多个线程，会共享这个进程的资源

线程：CPU调度的最小单位，必须依赖进程而存在。

- 什么是并行和并发

并行：同一时刻，可以同时处理事情的能力

并发：与单位时间相关，在单位时间内可以处理事情的能力

- 高并发编程的意义、好处和注意事项

好处：充分利用cpu的资源、加快用户响应的时间，程序模块化，异步化

问题：

线程共享资源，存在冲突；

容易导致死锁；

启用太多的线程，就有搞垮机器的可能

### 2、Java中线程基础

- 启动和终止线程

  - 三种启动线程的方式
  - 理解中断
  - 如何安全的终止线程

  线程自然终止：自然执行完或抛出未处理异常

  stop()，resume(),suspend()已不建议使用，stop()会导致线程不会正确释放资源，suspend()容易导致死锁。

  java线程是协作式，而非抢占式

  调用一个线程的interrupt() 方法中断一个线程，并不是强行关闭这个线程，只是跟这个线程打个招呼，将线程的中断标志位置为true，线程是否中断，由线程本身决定。

  isInterrupted() 判定当前线程是否处于中断状态。

  static方法interrupted() 判定当前线程是否处于中断状态，同时中断标志位改为false。

  方法里如果抛出InterruptedException，线程的中断标志位会被复位成false，如果确实是需要中断线程，要求我们自己在catch语句块里再次调用interrupt()。

- 线程再认识

  - 线程常用方法
  - 线程的状态

  线程只有5种状态。整个生命周期就是这几种状态的切换。

  run()和start() ：run方法就是普通对象的普通方法，只有调用了start()后，Java才会将线程对象和操作系统中实际的线程进行映射，再来执行run方法。

  yield() ：让出cpu的执行权，将线程从运行转到可运行状态，但是下个时间片，该线程依然有可能被再次选中运行。

  - 线程的优先级

  取值为1~10，缺省为5，但线程的优先级不可靠，不建议作为线程开发时候的手段

  #### Daemon线程

  在Java中有两类线程：用户线程 (User Thread)、守护线程 (Daemon Thread)。 

  所谓守护 线程，是指在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。

  用户线程和守护线程两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了，虚拟机也就退出了。 因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。

  将线程转换为守护线程可以通过调用Thread对象的setDaemon(true)方法来实现。在使用守护线程时需要注意一下几点：

   

  (1) thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。 

  (2) 在Daemon线程中产生的新线程也是Daemon的。

  (3) 守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。

  和主线程共死，finally不能保证一定执行

- 线程间的共享

  - synchronized

  	- 对象锁，锁的是类的对象实例。
  	- 类锁，锁的是每个类的的Class对象，每个类的的Class对象在一个虚拟机中只有一个，所以类锁也只有一个。
  - volatile

  适合于只有一个线程写，多个线程读的场景，因为它只能确保可见性。

  - ThreadLocal

  线程变量。可以理解为是个map，类型 Map<Thread,Integer>

- 线程间协作：轮询：难以保证及时性，资源开销很大，

	- 等待和通知机制

	  - Wait,Notify/NotifyAll
	  - 等待和通知的标准范式
	
  等待方：
	
	  1、 获取对象的锁；
	
	  2、 循环里判断条件是否满足，不满足调用wait方法，
	
	  3、 条件满足执行业务逻辑
	
	  通知方来说
	
	  1、 获取对象的锁；
	
	  2、 改变条件
	
	  3、 通知所有等待在对象的线程
	
	  - notify和notifyAll应该用谁
	
	  应该尽量使用notifyAll，使用notify因为有可能发生信号丢失的的情况
	
	  **等待超时模式实现一个连接池**
	
	  假设  等待时间时长为T，当前时间now+T以后超时
	
	   
	
	  long  overtime = now+T;
	
	  long remain = T;//等待的持续时间
	
	  while(result不满足条件&& remain>0){
	
	  ​	wait(remain);
	
	  ​	remain = overtime – now;//等待剩下的持续时间
	
	  }
	
	  return result;
	
	- Join方法
	
	线程A，执行了线程B的join方法，线程A必须要等待B执行完成了以后，线程A才能继续自己的工作
	
	- 调用yield() 、sleep()、wait()、notify()等方法对锁有何影响？
	
	线程在执行yield()以后，持有的锁是不释放的
	
	sleep()方法被调用以后，持有的锁是不释放的
	
	调动方法之前，必须要持有锁。调用了wait()方法以后，锁就会被释放，当wait方法返回的时候，线程会重新持有锁
	
	调动方法之前，必须要持有锁，调用notify()方法本身不会释放锁的

## 2、线程的并发工具类

### Fork/Join

- 什么是分而治之？

规模为N的问题，N<阈值，直接解决，N>阈值，将N分解为K个小规模子问题，子问题互相对立，与原问题形式相同，将子问题的解合并得到原问题的解

动态规范

- 工作密取
- 使用的标准范式

### CountDownLatch作用、应用场景和实战

作用：是一组线程等待其他的线程完成工作以后在执行，加强版join

await用来等待，countDown负责计数器的减一

### CyclicBarrier作用、应用场景和实战

让一组线程达到某个屏障，被阻塞，一直到组内最后一个线程达到屏障时，屏障开放，所有被阻塞的线程会继续运行CyclicBarrier(int parties)

CyclicBarrier(int parties, Runnable barrierAction)，屏障开放，barrierAction定义的任务会执行

### CountDownLatch和CyclicBarrier辨析

1、countdownlatch放行由第三者控制，CyclicBarrier放行由一组线程本身控制
2、countdownlatch放行条件》=线程数，CyclicBarrier放行条件=线程数

### Semaphore作用、应用场景和实战

控制同时访问某个特定资源的线程数量，用在流量控制

### Exchange作用、应用场景和实战

两个线程间的数据交换，

### Callable、Future和FutureTask

isDone，结束，正常还是异常结束，或者自己取消，返回true；

isCancelled 任务完成前被取消，返回true；

cancel（boolean）：

1、 任务还没开始，返回false

2、 任务已经启动，cancel（true），中断正在运行的任务，中断成功，返回true，cancel（false），不会去中断已经运行的任务

3、 任务已经结束，返回false

 

包含图片和文字的文档的处理：图片（云上），可以用future去取图片，主线程继续解析文字。

## 3、原子操作CAS

### 原子操作类

- CAS的原理
- CAS的问题

	- ABA问题
	- 开销
	- 只能保证一个共享变量的原子操作

- 原子操作类的使用

	- 基本类型
	- 数组
	- 引用
	- 带版本戳

## 4、显式锁和AQS

### 显式锁

- Lock接口、核心方法和使用
- Lock接口和synchronized的比较
- ReentrantLock

	- 可重入锁
	- 锁的公平和非公平

- ReentrantReadWriteLock

	- ReadWriteLock接口
	- 使用场景

- Condition接口

	- 用处
	- 用Lock和Condition实现等待通知

### 了解LockSupport

### AbstractQueuedSynchronizer

- 什么是AQS？学习它的必要
- AQS使用方式和其中的设计模式
- 了解其中的方法
- 实现一个自己的独占锁 
- 深入源码

	- AQS中的数据结构
	- 节点在同步队列中的增加和移出
	- 独占式同步状态获取与释放
	- 共享式同步状态获取与释放
	- Condition分析

		- 等待队列
		- await方法
		- signal方法

- 了解ReentrantLock的实现

	- 锁的可重入
	- 公平和非公平锁

- 了解ReentrantReadWriteLock的实现

## 9、JMM和底层实现原理

### 现代计算机物理
上的内存模型

- 概念
- 带来的问题

### Java内存模型
（JMM）

- JVM对Java内存
模型的实现
- 带来的问题
- 重排序

	- 类型
	- 依赖性
	- as-if-serial
	- 重排序带来的问题
	- 内存屏障
	- 临界区

- Happens-Before

	- 定义
	- 规则

- volatile的内存语义

	- 概念和深入理解
	- 内存语义的实现

		- 重排序规则
		- 内存屏障插入策略

- 锁的内存语义
- final的内存语义
- volatile的实现原理
- synchronized的实现原理

## 8、实战项目(2个)

### 并发任务执行框架

- 需求的产生和分析 
- 需要做什么

	- 封装多线程，屏蔽细节
	- 保存任务的上下文
	- 自动清除已完成和过期任务

- 具体实现

	- 可查询进度的并发任务执行框架

### 应用性能优化实战

- 项目简介
- 项目分析，为何优化
- 分析和改进

	- 架构改进
	- 单服务改进

- 如何继续改进
- 带来的启示

## 7、并发安全

### 类的线程安全

### 如何做到类的线程安全

- 无状态
- 让类不可变
- 更多......

### 线程不安全引发的问题

- 死锁

	- 原因
	- 表现
	- 检测和解决

- 活锁
- 多线程程序
性能和思考

	- 影响性能的因素
	- 减少锁的竞争

### 线程安全的单例模式

- 如何让双重检查锁定安全
- 懒汉式
- 饿汉式

## 6、线程池

### 什么是线程池？为什么要用线程池？

### 实现一个我们自己的线程池

### JDK中的线程池

- 线程池的创建
- 提交任务
- 关闭线程池

### 线程池工作机制

### 合理配置线程池

### 系统为我们预定义的线程池

- FixedThreadPool
SingleThreadExecutor
CachedThreadPool
WorkStealingPool

	- 含义
	- 使用场景

- ScheduledThreadPoolExecutor

	- 含义
	- 使用场景
	- 内部方法辨析

### Executor框架

### CompletionService

- 使用
- 优点

## 5、并发容器

### ConcurrentHashMap

- 使用
- 实现

	- 基本思想
	- 预备知识

		- Hash
		- 位运算

	- jdk1.7

		- 构造方法
		- 如何定位
		- get方法
		- put方法
		- 扩容

	- jdk1.8

		- 构造方法
		- 如何定位
		- get方法
		- put方法
		- 扩容

### 其他并发容器

- ConcurrentSkipListMap等

	- 了解什么是SkipList

- ConcurrentLinkedQueue  
- 写时复制容器

### 阻塞队列

- 概念
- 生产者消费者模式
- 常用方法
- 常用阻塞队列辨析

	- ·ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。
·LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。
·PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。
·DelayQueue：一个使用优先级队列实现的无界阻塞队列。
·SynchronousQueue：一个不存储元素的阻塞队列。
·LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。
·LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。

- 延时队列实战
- 阻塞队列实现原理

*XMind: ZEN - Trial Version*