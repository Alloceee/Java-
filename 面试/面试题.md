## Java中对象序列化接口(Serializable)的意义

Serializable接口是一个里面什么都没有的接口
它的源代码是public interface Serializable{}，即什么都没有。
如果一个接口里面什么内容都没有，那么这个接口是一个标识接口，比如，一个学生遇到一个问题，排错排了几天也没解决，此时，她举手了（示意我去帮他解决），然后我过去，帮他解决了，那么这个举手其实就是一个标识，自己不能解决的问题标示我去帮他解决，在Java中的这个Serializable接口是给JVM看的，告诉JVM，我不做这个类的序列化了，你(JVM)给我序列化，序列化就是变成二进制流，比如云计算、Hadoop，特别是Hadoop完全就是分布式环境，那么就要涉及到对象要在网络中传输，里面的全是二进制流，当然你来做这个序列化操作也可以，但是这个类里面可能还有一个类，如果你把外面的类对象Person变成二进制，那么里面也要序列化（这要用到深度遍历，很麻烦），干脆告诉JVM，让他来帮你做。

## 为什么string是final的





### MyBatis的缓存功能使用HashMap实现会不会出现并发安全的问题





## 什么情况下使用表锁，什么情况下使用行锁？







## 强弱引用的区别





## 内存溢出与内存泄漏的区别



## 索引失效的情况





## 幻读和不可重复读的区别







## 请详细描述从数据库连接池中获取一个连接资源的过程





请描述声明式事务底层实现的原理和



拦截器与过滤器的区别

mvc拦截器=aop

filter=servlet规范里

**1. synchronized 和 reentrantlock 异同**

**相同点**

都实现了多线程同步和内存可见性语义，都是可重入锁

**不同点**

实现机制不同 synchronized 通过 java 对象头锁标记和 Monitor 对象实现 reentrantlock 通过CAS、ASQ（AbstractQueuedSynchronizer）和 locksupport（用于阻塞和解除阻塞）实现synchronized 依赖 jvm 内存模型保证包含共享变量的多线程内存可见性 reentrantlock 通过 ASQ 的volatile state 保证包含共享变量的多线程内存可见性

使用方式不同 synchronized 可以修饰实例方法（锁住实例对象）、静态方法（锁住类对象）、代码块（显示指定锁对象）reentrantlock 显示调用 trylock()/lock() 方法，需要在 finally 块中释放锁功能丰富程度不同 reentrantlock

提供有限时间等候锁（设置过期时间）、可中断锁（lockInterruptibly）、condition（提供 await、signal等方法）等丰富语义 reentrantlock 提供公平锁和非公平锁实现 synchronized不可设置等待时间、不可被中断（interrupted）

**2. concurrenthashmap 为何读不用加锁**

**jdk1.7**

1）HashEntry 中的 key、hash、next 均为 final 型，只能表头插入、删除结点

2）HashEntry 类的 value 域被声明为 volatile 型

3）不允许用 null 作为键和值，当读线程读到某个 HashEntry 的 value 域的值为 null时，便知道产生了冲突——发生了重排序现象（put 设置新 value 对象的字节码指令重排序），需要加锁后重新读入这个 value 值

4）volatile 变量 count 协调读写线程之间的内存可见性，写操作后修改 count，读操作先读 count，根据happen-before 传递性原则写操作的修改读操作能够看到

**jdk1.8**

1）Node 的 val 和 next 均为 volatile 型

2）tabAt 和 casTabAt 对应的 unsafe 操作实现了 volatile 语义

**3. ContextClassLoader（线程上下文类加载器）的作用**

越过类加载器的双亲委派机制去加载类，如 serviceloader 实现使用线程上下文类加载器加载类，要注意保证多个需要通信的线程间的类加载器应该是同一个，防止因为不同的类加载器导致类型转换异常(ClassCastException)

**4. tomcat 类加载机制**

**![1.jpg](http://10.7.0.6/Public/ueditor/php/upload1/20181011/1539223926704110.jpg)**

不同应用使用不同的 webapp 类加载器，实现应用隔离的效果，webapp 类加载器下面是jsp类加载器；不同应用共享的 jar 包可以放到 Shared 类加载器 /shared 目录下

**5. osgi 类加载机制**

**![2.png](http://10.7.0.6/Public/ueditor/php/upload1/20181011/1539223946985966.png)**

osgi 类加载模型是网状的，可以在模块（Bundle）间互相委托

osgi 实现模块化热部署的关键是自定义类加载器机制的实现，每个 Bundle 都有一个自己的类加载器，当需要更换一个 Bundle时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换

当收到类加载请求时，osgi 将按照下面的顺序进行类搜索：

1）将以 java.* 开头的类委派给父类加载器加载

2）否则，将委派列表名单（配置文件 org.osgi.framework.bootdelegation 中定义）内的类委派给父类加载器加载

3）否则，检查是否在 Import-Package 中声明，如果是，则委派给 Export 这个类的 Bundle 的类加载器加载

4）否则，检查是否在 Require-Bundle 中声明，如果是，则将类加载请求委托给 required bundle 的类加载器

5）否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载

6）否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委派给 Fragment Bundle 的类加载器加载

7）否则，查找 Dynamic Import-Package（Dynamic Import 只有在真正用到此 Package的时候才进行加载）的 Bundle，委派给对应 Bundle 的类加载器加载

8）否则，类查找失败

**6. 如何结束一个一直运行的线程**

使用退出标志，这个 flag 变量要多线程可见

使用 interrupt，结合 isInterrupted() 使用

**7. threadlocal 使用场景及问题**

threadlocal 并不能解决多线程共享变量的问题，同一个 threadlocal 所包含的对象，在不同的 thread中有不同的副本，互不干扰

用于存放线程上下文变量，方便同一线程对变量的前后多次读取，如事务、数据库 connection 连接，在 web 编程中使用的更多

问题： 注意线程池场景使用 threadlocal，因为实际变量值存放在了 thread 的 threadlocalmap类型变量中，如果该值没有 remove，也没有先 set 的话，可能会得到以前的旧值

问题： 注意线程池场景下的内存泄露，虽然 threadlocal 的 get/set 会清除 key（key 为 threadlocal的弱引用，value 是强引用，导致 value 不释放）为 null 的 entry，但是最好 remove

**8. 线程池从启动到工作的流程**

刚创建时，里面没有线程调用 execute() 添加任务时：

1）如果正在运行的线程数量小于核心参数 corePoolSize，继续创建线程运行这个任务

2）否则，如果正在运行的线程数量大于或等于 corePoolSize，将任务加入到阻塞队列中

3）否则，如果队列已满，同时正在运行的线程数量小于核心参数 maximumPoolSize，继续创建线程运行这个任务

4）否则，如果队列已满，同时正在运行的线程数量大于或等于 maximumPoolSize，根据设置的拒绝策略处理

5）完成一个任务，继续取下一个任务处理

6）没有任务继续处理，线程被中断或者线程池被关闭时，线程退出执行，如果线程池被关闭，线程结束

7）否则，判断线程池正在运行的线程数量是否大于核心线程数，如果是，线程结束，否则线程阻塞。因此线程池任务全部执行完成后，继续留存的线程池大小为corePoolSize

8）本文所列出的 14 个 Java面试题只是我所遭遇的面试中的一部分，其他的面试题我也会陆续整理出来，说到这里另外顺便给大家推荐一个架构交流学习群：650385180，里面会分享一些资深架构师录制的视频录像：有Spring，MyBatis，Netty 源码分析，高并发、高性能、分布式、微服务架构的原理，JVM性能优化这些成为架构师必备的知识体系。还能领取免费的学习资源，相信对于已经工作和遇到技术瓶颈的码友，在这个群里会有你需要的内容。

**9. 阻塞队列 BlockingQueue take 和 poll 区别**

poll(time)：取走 BlockingQueue 里排在首位的对象, 若不能立即取出，则可以等 time参数规定的时间，取不到时返回 null

take()：取走 BlockingQueue 里排在首位的对象，若 BlockingQueue 为空，阻塞直到BlockingQueue 有新的对象被加入

**10. 如何从 FutureTask 不阻塞获取结果**

get(long timeout,TimeUnit unit)，超时则返回

轮询，先通过 isDone()判断是否结束，然后调用 get()

**11. blockingqueue 如果存放了比较关键的数据，系统宕机该如何处理**

将队列持久化，比较麻烦，需要将生产数据持久化到磁盘，持久化成功才返回，消费者线程从磁盘加载数据到内存阻塞队列中，维护消费offset，启动时，根据消费 offset 从磁盘加载数据

加入消息队列，保证消息不丢失，生成序列号，消费幂等，根据消费进程决定系统重启后的生产状态



**13. list 中存放可重复字符串，如何删除某个字符串**

调用 iterator 相关方法删除

倒删，防止正序删除导致的数组重排，index 跳过数组元素问题

**14. 有哪些 GC ROOTS（跟日常开发比较相关的是和此相关的内存泄露）**

所有 Java 线程当前活跃的栈帧里指向 GC 堆里的对象的引用，因此用不到的对象及时置 null，提升内存回收效率

静态变量引用的对象，因此减少静态变量特别是静态集合变量的大小，集合存放的对象覆写 euqls()和 hashcode()，防止持续增长

本地方法 JNI 引用的对象

方法区中的常量引用的对象，因此减少在长字符串上调用 String.intern()

classloader 加载的 class 对象，因此自定义 classloader 无效时及时置 null并且注意类加载器加载对象之间的隔离

jvm 里的一些静态数据结构里指向 GC 堆里的对象的引用 

14、叙述Session的缓存的作用？

- 减少访问数据库的频率。应用程序从内存中读取持久化对象的速度显然比到数据库中查询数据的速度快多了，因此Session的缓存可以提高数据访问的性能。
- 保证缓存中的对象与数据库中的相关记录保持同步。当缓存中持久化对象的状态发生了变换，Session并不会立即执行相关的SQL语句，这使得Session能够把几条相关的SQL语句合并为一条SQL语句，以便减少访问数据库的次数，从而提高应用程序的性能。

15、Session的清理和清空有什么区别？

Session清理缓存是指按照缓存中对象的状态的变化来同步更新数据库；清空是Session的关闭；

16、请简述Session的特点有哪些？

- 不是线程安全的，因此在设计软件架构时，应该避免多个线程共享同一个Session实例。
- Session实例是轻量级的，所谓轻量级是指它的创建和销毁不需要消耗太多的资源。这意味着在程序中可以经常创建或销毁Session对象，例如为每个客户请求分配单独的Session实例，或者为每个工作单元分配单独的Session实例。
- 在Session中，每个数据库操作都是在一个事务(transaction)中进行的，这样就可以隔离开不同的操作（甚至包括只读操作）。

17、比较Hibernate三种检索策略的优缺点？

- 立即检索
- 优点：对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便的从一个对象导航到与它关联的对象；
- 缺点：1.select语句太多；2.可能会加载应用程序不需要访问的对象白白浪费许多内存空间；

- 延迟检索

- 优点：由应用程序决定需要加载哪些对象，可以避免可执行多余的select语句，以及避免加载应用程序不需要访问的对象。因此能提高检索性能，并且能节省内存空间；
- 缺点：应用程序如果希望访问游离状态代理类实例，必须保证他在持久化状态时已经被初始化；

- 迫切左外连接检索

- 优点：1、对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便地冲一个对象导航到与它关联的对象。2、使用了外连接，select语句数目少；
- 缺点：1、可能会加载应用程序不需要访问的对象，白白浪费许多内存空间；2、复杂的数据库表连接也会影响检索性能；