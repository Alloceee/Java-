## 阐述事务的隔离级别和传播属性

七个事务传播属性

| 传播属性                  | 介绍                                                         |
| ------------------------- | ------------------------------------------------------------ |
| PROPAGATION_REQUIRED      | 支持当前事务，如果当前没有事务，就建立一个事务。这是最常见的选择（默认值） |
| PROPAGATION_SUPPORTS      | 支持当前事务，如果当前没有事务，就以非事务方式运行           |
| PROPAGATION_MANDATORY     | 支持当前事务，如果当前没有事务，就抛出异常                   |
| PROPAGATION_REQUIRES_NEW  | 新建事务，如果当前存在事务，把当前事务挂起                   |
| PROPAGATION_NOT_SUPPORTED | 以非事务方式执行操作，如果当前存在事务，就把事务挂起         |
| PROPAGATION_NEVER         | 以非事务方式执行，如果当前存在事务，则抛出异常               |
| PROPAGATION_NESTED        | 如果当前存在事务，则在嵌套事务内执行，如果当前没有事务则与PROPAGATION_REQUIRED类似的操作 |

> @Transactional(propagation = propagation.REQUIRED)默认属性

五种隔离级别

| 隔离级别                               | 含义                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| ISOLUTION_DEFAULT                      | 这是一个PlatfromTransationManager默认的隔离级别，使用数据库默认的事务隔离级别，另外四个与JDBC隔离级别相对应 |
| ISOLUTION_READ_UNCOMMITTED（读未提交） | 这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据，这种隔离级别会产生脏读，不可重复读和幻想读 |
| ISOLUTION_READ_COMMITTED（读已提交）   | 保证一个事务修改的数据提交后才能被另外一个事务读取，另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻读 |
| ISOLUTION_REPEATABLE_READ（可重复读）  | 这种事务隔离可以防止脏读，不可重复读，但是可能出现幻读，它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免不可重复读 |
| ISOLUTION_SERIALIZABLE（串行化）       | 这是花费最高代价但是最可靠的事务隔离级别，事务被处理为顺序执行，处理防止脏读，不可重复读外，还避免了幻读 |

> 脏读是指一个事务读取到了另一个事务未提交的数据
>
> 不可重复读是指**一个事务内**多次根据同一个查询条件查询出来的同一行记录的值不一样（例如一个事务还没有结束，另一个事务也访问该数据并进行修改，那么可能后一次读出来修改后的数据）。
>
> 一个事务修改完成，另一个事务才可以读取就可以解决这个问题。
>
> 幻读是【当事务不是独立执行时发生的一种现象】指**一个事务**多次根据同个条件查出来的记录行数不一样。（例如一个事务对表中的数据进行修改，同时另一个事务对表中的数据进行添加或者删除，那么以后操作第一个事务的会发现有自己未修改的新添加的数据行）。
>
> 如果在对数据进行修改未完成之前，不允许对数据库进行添加或者删除就可以避免该问题。

不可重复读的重点是修改：

同样的条件，你读取过的数据，再次读取出来发现值不一样了

幻读的重点在于新增或删除：

同样的条件，第一次和第二次读出来的记录数不一样

