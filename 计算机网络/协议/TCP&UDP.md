## OSI七层模型各层的作用

| **层名**   | **作用**                                                     |
| ---------- | ------------------------------------------------------------ |
| 应用层     | 网络服务与最终用户的一个接口                                 |
| 表示层     | 把应用层提供的信息变换为能够共同理解的形式                   |
| 会话层     | 建立、管理、终止会话。                                       |
| 传输层     | 定义传输数据的协议端口号，以及流控和差错校验。               |
| 网络层     | 路由选择和中继，在一条数据链路上复用多条网络连接             |
| 数据链路层 | 数据链路的建立，拆除，对数据的检错，纠错是数据链路层的基本任务。 |
| 物理层     | 物理层并不是物理媒体本身，它只是开放系统中利用物理媒体实现物理连接的功能描述和执行连接的规程。 |

## TCP/IP协议

Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。协议采用了4层的层级结构。然而在很多情况下，它是利用 IP 进行通信时所必须用到的协议群的统称。

![1569499540105](C:\Users\AlmostLover\Desktop\MarkDown笔记\计算机网络\协议\1569499540105.png)

## TCP 和 UDP

TCP 是面向连接的、可靠的流协议，通过三次握手建立连接，通讯完成时要拆除连接。
UDP是面向无连接的通讯协议，UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象。

| TCP                                                          | UDP                                                          |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 面向连接                                                     | 无连接，即发送数据前不需要建立连接                           |
| 提供可靠服务，也就是说，通过TCP传输的数据无差错，不丢失，不重复，且按顺序到达 | 尽最大努力交付，即不保证可靠交付                             |
| 面向字节流                                                   | 面向报文，并且网络出现阻塞不会使得发送速率降低，因此会出现丢包 |
| 只能1对1                                                     | 支持1对1，1对多                                              |
| 首部较大，为20字节                                           | 8字节                                                        |

![1569499961551](C:\Users\AlmostLover\Desktop\MarkDown笔记\计算机网络\协议\1569499961551.png)



### 三次握手和四次分手

![1569501732187](C:\Users\AlmostLover\Desktop\MarkDown笔记\计算机网络\协议\1569501732187.png)

### TCP/IP中的数据包

  包是全能性术语；
  帧用于表示数据链路层中包的单位；
  片是 IP中数据的单位；
  段则表示 TCP 数据流中的信息；
  消息是指应用协议中数据的单位。

![1569501853899](C:\Users\AlmostLover\Desktop\MarkDown笔记\计算机网络\协议\1569501853899.png)

### TCP 中通过序列号与确认应答提高可靠性

![1569501962841](C:\Users\AlmostLover\Desktop\MarkDown笔记\计算机网络\协议\1569501962841.png)

### HTTP请求的传输过程

![1569502381482](C:\Users\AlmostLover\Desktop\MarkDown笔记\计算机网络\协议\1569502381482.png)

### 一次完整http请求的7个过程

1. 建立 TCP 连接（之前可能还有一次DNS域名解析）
2. 客户端向服务器发送请求命令
3. 客户端发送请求头信息
4. 服务服务器应答器
5. 返回响应头信息
6. 服务器向客户端发送数据
7. 服务器关闭 TCP 连接

### HTTP 协议报文结构

![1569502556473](C:\Users\AlmostLover\Desktop\MarkDown笔记\计算机网络\协议\1569502556473.png)

### 请求报文结构

![1569502931858](C:\Users\AlmostLover\Desktop\MarkDown笔记\计算机网络\协议\1569502931858.png)

### 响应报文结构

![1569502954390](C:\Users\AlmostLover\Desktop\MarkDown笔记\计算机网络\协议\1569502954390.png)

### Socket

Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。

![1569504199474](C:\Users\AlmostLover\Desktop\MarkDown笔记\计算机网络\协议\1569504199474.png)

**Socket**是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。

**短连接：**

连接->传输数据->关闭连接
   HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。
   也可以这样说：短连接是指SOCKET连接后发送后接收完数据后马上断开连接。

 **长连接：**

连接->传输数据->保持连接 -> 传输数据-> 。。。 ->关闭连接。
   长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。

**什么时候用长连接，短连接？**

​    长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。

 而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。

 总之，长连接和短连接的选择要视情况而定。



### Linux网络IO模型

#### 同步和异步，阻塞和非阻塞

![1569504299986](C:\Users\AlmostLover\Desktop\MarkDown笔记\计算机网络\协议\1569504299986.png)

#### 阻塞I/O（blocking I/O）

![1569504383332](C:\Users\AlmostLover\Desktop\MarkDown笔记\计算机网络\协议\1569504383332.png)



进程会一直阻塞，直到数据拷贝完成

应用程序调用一个IO函数，导致应用程序阻塞，等待数据准备好。 如果数据没有准备好，一直等待….数据准备好了，从内核拷贝到用户空间,IO函数返回成功指示。

 当调用recv()函数时，系统首先查是否有准备好的数据。如果数据没有准备好，那么系统就处于等待状态。当数据准备好后，将数据从系统缓冲区复制到用户空间，然后该函数返回。在套接应用程序中，当调用recv()函数时，未必用户空间就已经存在数据，那么此时recv()函数就会处于等待状态。

#### 非阻塞IO模型

![1569504580216](C:\Users\AlmostLover\Desktop\MarkDown笔记\计算机网络\协议\1569504580216.png)

非阻塞IO通过进程反复调用IO函数（多次系统调用，并马上返回）；在数据拷贝的过程中，进程是阻塞的；

 我们把一个SOCKET接口设置为非阻塞就是告诉内核，当所请求的I/O操作无法完成时，不要将进程睡眠，而是返回一个错误。这样我们的I/O操作函数将不断的测试数据是否已经准备好，如果没有准备好，继续测试，直到数据准备好为止。在这个不断测试的过程中，会大量的占用CPU的时间。上述模型绝不被推荐。

​    把SOCKET设置为非阻塞模式，即通知系统内核：在调用Windows Sockets API时，不要让线程睡眠，而应该让函数立即返回。在返回时，该函数返回一个错误代码。图所示，一个非阻塞模式套接字多次调用recv()函数的过程。前三次调用recv()函数时，内核数据还没有准备好。因此，该函数立即返回WSAEWOULDBLOCK错误代码。第四次调用recv()函数时，数据已经准备好，被复制到应用程序的缓冲区中，recv()函数返回成功指示，应用程序开始处理数据。

#### IO复用模型

![1569504757370](C:\Users\AlmostLover\Desktop\MarkDown笔记\计算机网络\协议\1569504757370.png)

select和epoll；对一个socket，两次调用，两次返回，比阻塞IO并没有什么优越性；
关键是能实现同时对多个socket进行处理。

​      简介：主要是select和epoll；对一个IO端口，两次调用，两次返回，比阻塞IO并没有什么优越性；关键是能实现同时对多个IO端口进行监听；

​      I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数。

当用户进程调用了select，那么整个进程会被block；而同时，kernel会“监视”所有select负责的socket；当任何一个socket中的数据准备好了，select就会返回。这个时候，用户进程再调用read操作，将数据从kernel拷贝到用户进程。
    这个图和blocking IO的图其实并没有太大的不同，事实上还更差一些。因为这里需要使用两个系统调用(select和recvfrom)，而blocking IO只调用了一个系统调用(recvfrom)。但是，用select的优势在于它可以同时处理多个connection。（select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）

#### 信号驱动IO

![1569504860009](C:\Users\AlmostLover\Desktop\MarkDown笔记\计算机网络\协议\1569504860009.png)

套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。
当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。

​     简介：两次调用，两次返回；

​    首先我们允许套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。

#### 异步IO模型

![1569504880359](C:\Users\AlmostLover\Desktop\MarkDown笔记\计算机网络\协议\1569504880359.png)

当一个异步过程调用发出后，调用者不能立刻得到结果。
实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者的输入输出操作。

#### 5个I/O模型的比较：

![1569504903380](C:\Users\AlmostLover\Desktop\MarkDown笔记\计算机网络\协议\1569504903380.png)



select、poll、epoll的区别



# **5个I/O模型的比较**

## select、poll、epoll的区别？：

 1、支持一个进程所能打开的最大连接数

| select | 单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32\*32，同理64位机器上FD_SETSIZE为32*64），可以对进行修改，然后重新编译内核，但是性能可能会受到影响。 |
| ------ | ------------------------------------------------------------ |
| poll   | poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的 |
| epoll  | 连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接 |

2、FD剧增后带来的IO效率问题

| select | 因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。 |
| ------ | ------------------------------------------------------------ |
| poll   | 同上                                                         |
| epoll  | 因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。 |

3、 消息传递方式

| select | 内核需要将消息传递到用户空间，都需要内核拷贝动作 |
| ------ | ------------------------------------------------ |
| poll   | 同上                                             |
| epoll  | epoll通过内核和用户空间共享一块内存来实现的。    |

## **补充知识点：**

#### **Level_triggered(水平触发)：**

当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait()时，它还会通知你在上没读写完的文件描述符上继续读写，当然如果你一直不去读写，它会一直通知你！！！如果系统中有大量你不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率！！！

#### **Edge_triggered(边缘触发)：**

当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符！！

 select(),poll()模型都是水平触发模式，信号驱动IO是边缘触发模式，epoll()模型即支持水平触发，也支持边缘触发，默认是水平触发。



#### 原生JDK网络编程

![1569504930317](C:\Users\AlmostLover\Desktop\MarkDown笔记\计算机网络\协议\1569504930317.png)

#### 原生JDK网络编程- AIO

![1569506498497](C:\Users\AlmostLover\Desktop\MarkDown笔记\计算机网络\协议\1569506498497.png)

#### 原生JDK网络编程- NIO之Reactor模式

![1569506803110](C:\Users\AlmostLover\Desktop\MarkDown笔记\计算机网络\协议\1569506803110.png)

#### 原生JDK网络编程- NIO

![1569506826836](C:\Users\AlmostLover\Desktop\MarkDown笔记\计算机网络\协议\1569506826836.png)

#### 原生JDK网络编程- Buffer

![1569506845761](C:\Users\AlmostLover\Desktop\MarkDown笔记\计算机网络\协议\1569506845761.png)



114.TCP和UDP区别

参考[TCP和UDP的区别（转） - bizhu - 博客园](https://link.zhihu.com/?target=http%3A//www.cnblogs.com/bizhu/archive/2012/05/12/2497493.html)

## **socket通信**

（tcp/udp区别及JAVA的实现方式）TCP——传输控制协议，具有极高的可靠性，保
证数据包按照顺序准确到达，但其也有着很高的额外负担。UDP——使用者数据元协议，并不能保证
数据包会被成功的送达，也不保证数据包到达的顺序，但其传输速度很快。大多数我们会使用TCP，
偶尔才会动用UDP，如声音讯号，即使少量遗失，也无关紧要。

# TCP

### 什么是TCP粘包和拆包

* 要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包
* 将发送数据大于MSS(最大报文长度)，TCP在传输前将进行拆包
* 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包
* 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包

### TCP粘包和拆包的解决方法

* 发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了
* 发送端将每个数据包封装为固定长度（不够可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来
* 可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包分开

