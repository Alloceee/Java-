### 全文搜索

FULLTEXT()添加索引，参数为需要添加索引的列

在索引之后，使用函数match()和against()执行全文搜索

```sql
select note_text from pro where Match(note_text) Against("rabbit");
```

Match()针对指定的列进行搜索，Against()指定搜索的关键词

> 传递给Match()的此必须和FULLTEXT()定义中的相同，如果指定多个列，则必须列出它们（而且次序正确）
>
> 搜索不区分大小写，除非使用BINARY方式

使用全文搜索比模糊查询的好处就是，全文搜索可以对结果进行排序，具有包含搜索词作为靠前的比靠后的优先级高，具有优先级高的先返回，因为这些行很可能是你真正想要的行。

如果指定多个搜索项，则包含多数匹配词的那些行将具有比包含少词（或仅有一个匹配）的那些行高的等级值。

#### 查询拓展

```sql
select note_text from pro where Match(note_text) Against("rabbit" WITH QUERY EXPANSION);
```

首先，进行一个基本的全文搜索，找出与搜索条件匹配的所有行

其次，MySQL检查这些匹配行并进行所有有用的词

再其次，MySQL再次进行全文搜索，这次不仅使用原来的条件，而且还使用所有有用的词

### 触发器

只有表支持触发器，视图不支持，临时表也不支持

```sql
CREATE TRIGGER newproduct ALTER INSERT ON products FOR EACH ROW SELECT 'Product added'
```

### 视图

#### 为什么使用视图

1. 重用SQL语句
2. 简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节
3. 使用表的组成部分而不是整个表
4. 保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限
5. 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据

视图仅仅是用来看存储在别处的数据的一种措施。视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据。

#### 视图的规则和限制

1. 与表一样，视图必须唯一命名
2. 对于可以创建的视图数目没有限制
3. 为了创建视图，必须具有足够的访问权限，这些权限通常由数据库管理人员授予
4. 视图可以嵌套
5. ORDER BY 可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。
6. 视图不能索引，也不能有关联的触发器或默认值
7. 视图可以和表一起使用。

## 对MySQL常见的两种存储引擎：MyISAM与InnoDB的理解

### MyISAM

MyISAM5.5之前默认的存储引擎，由MYD和MYI组成

#### 特点：

并发性与锁级别- 表级锁

支持全文检索

支持数据压缩

#### 适用场景：

非事务性应用（数据仓库，报表，日志数据）

只读类应用

空间类应用（空间函数，坐标）

### Innodb

MySQL5.5及其以后默认存储引擎

mysql5.6以前默认为系统表空间

系统表空间和独立表空间

- 系统表空间无法简单的收缩文件大小
- 独立表空间可以通过optimize table收缩系统文件
- 系统表空间会产生IO瓶颈
- 独立表空间可以同时向多个文件刷新数据

> 建议：Innodb使用独立表空间

#### 特点：

Innodb是一种事务性存储引擎，完全支持事务的ACID特性

Redo Log和Undo Log

Innodb支持行级锁（并发程序更高）

#### 适用场景：

Innodb适用于大多数OLTP应用

#### 对比：

| 对比项   | MyISAM                                                 | InnoDB                                                       |
| -------- | ------------------------------------------------------ | ------------------------------------------------------------ |
| 主外键   | 不支持                                                 | 支持                                                         |
| 事务     | 不支持                                                 | 支持                                                         |
| 行表锁   | 表锁，即使操作一条记录也会锁住整个表，不适合高并发操作 | 行锁，操作时只锁住某一行，不对其他行有影响，适合高并发的操作 |
| 缓存     | 只缓存索引，不缓存真实数据                             | 不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响 |
| 表空间   | 小                                                     | 大                                                           |
| 关注点   | 性能                                                   | 事务                                                         |
| 默认安装 | Y                                                      | Y                                                            |



#### 两者的对比：

1. count运算上的区别：因为MyISAM缓存有表meta-data(行数等)，因此在做COUNT(*)时对于一个结构很好的查询是不需要消耗多少资源的，而对于InnoDB来说，是没有这种缓存的。
2. 是否支持事务和崩溃后的安全恢复：MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB类型更快，但是不提供事务支持。但是InnoDB提供事务支持，外键等高级数据库功能，具有事务（commit），回滚（callback）和崩溃恢复（crash recovery capabilities）的事务安全（transaction-safe(ACID compliant)）型表。
3. 是否支持外键：MyISAM不支持，InnoDB支持

#### 两者的总结：

MyISAM更适合读密集的表，而InnoDB更适合写更密集的表。在数据库主从分离的情况下，经常选择MyISAM作主库的搜索引擎。

#### 其他存储引擎

##### CSV

组成：数据以文本方式存储在文件，.cvs文件存储内容，.csm文件存储表的元数据如表状态和数据量，.frm表结构

特点：

1. 以csv格式进行数据存储
2. 所有列都不能为null
3. 不支持索引（不适合大表，不适合在线处理）
4. 可以对数据文件直接编辑（保存文本文件内容）

##### Archive

组成：以zlib对表数据进行压缩，磁盘I/O更少，数据存储在ARZ为后缀的文件中

特点：只支持insert和select操作，只允许自增ID列上加索引

使用场景：日志和数据采集应用

##### Memory

- 文件系统存储特点，也称HEAP存储引擎，所以数据保存在内存中
- 支持HASH索引和BTree索引
- 所有字段都是固定长度varchar(10)=char(10)
- 不支持Blog和Text等大字段
- Memory存储引擎使用表级锁
- 最大大小由max_heap_table_size参数决定

![1568891389991](C:\Users\AlmostLover\Desktop\MarkDown笔记\数据库\1568891389991.png)

使用场景：

hash索引用于查找或者是映射表（邮编和地区的对应表）

用于保存数据分析中产生的中间表

用于缓存周期性聚合数据的结果表

> memory数据易丢失，所以要求数据可再生

## 锁

### 为什么需要锁

到淘宝上买一件商品，商品只有一件库存，这个时候如果还有另一个人买，那么如何解决是你买到还是另一个人买到的问题。

1. 我们先从库存表中取出物品数量
2. 然后插入订单
3. 付款后插入付款表信息
4. 然后更新商品数量

在这个过程中，使用锁可以对有限的资源进行保护，解决隔离和并发的矛盾

### 锁的概念

锁是计算机协调多个线程或线程并发访问某一资源的机制

在数据库中，数据也是一种供许多用户共享的资源。如果保护数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。

锁对数据库而言显得尤其重要，也更加复杂。

### MySQL中的锁

MySQL的锁机制比较简单

其最显著的特点是不同的存储引擎支持不同的锁机制

比如：MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）;

InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。

表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

行级锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率最低，并发度也最高。

页面锁：开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。

仅从锁的角度来说：

表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如OLAP系统

行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。

### MyISAM的表锁

#### MySQL的表级锁有两种模式：

表共享读锁（Table Read Lock）

表独占写锁（Table Write Lock）

| 请求锁模式  是否兼容  当前锁模式 | None | 读锁 | 写锁 |
| -------------------------------- | ---- | ---- | ---- |
| 读锁                             | 是   | 是   | 否   |
| 写锁                             | 是   | 否   | 否   |

共享读锁语法

给表加锁  加共享读锁

lock table 表名 read

\1. lock table testmysam READ 启动另外一个session select * from 

testmysam 可以查询 

\2. insert into testmysam value(2); 

update testmysam set id=2 where id=1; 

报错 

3.在另外一个session中 

insert into testmysam value(2); 等待 

4.在同一个session中 

insert into testdemo value(2,'2','3'); 报错 

select * from testdemo ; 报错 

5.在另外一个session中 

insert into testdemo value(2,'2','3'); 成功 

6.加索在同一个session 中 select s.* from testmysam s 报错 

lock table 表名 as 别名 read;

查看 show status LIKE 'table_locks_waited' 表被锁过几次

表独占写锁语法

给表加锁

加独占写锁

lock table 表名 write

**总结**

- 对MyISAM表的读操作，不会阻塞其他用户对同一表的读操作，但会阻塞对同一表的写请求
- 对MyISAM表的读操作，不会阻塞当前session对表读，当对表进行修改会保存
- 一个session使用LOCK TABLE命令给表f加了读锁，这个session可以查询锁定表中的记录，但更新或访问其他表都会提示错误；
- 另外一个session可以查询表中的记录，但更新就会出现锁等待
- 对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作
- 对MyISAM表的写操作，当前session可以对本表做CURD，但对其他表进行操作会报错

### InnoDb行锁

在mysql的InnoDB引擎支持行锁

行锁：

共享锁又称：读锁。当一个事务对某几行上读锁时，允许其他事务对这几行进行读操作，但不允许其进行写操作，也不允许其他事务给这几行上排它锁，但允许上读锁。

排他锁又称：写锁。当一个事务对某几行上写锁时，不允许其他事务写，但允许读。更不允许其他事务给这几行上任何锁，包括写锁。

写法：

```
//上共享锁的写法：lock in share mode
select * from 表 where 条件 lock in share mode
//上排它锁写法：for update
select * from 表 where 条件 for update
```

**注意**：

1. 两个事务不能锁同一个索引；
2. Insert,delete,update在事务中都会自动默认加上排他锁
3. 行锁必须有索引才能实现，否则会自动锁全表，那么就不是行锁了

#### InnoDb表锁

和MyISAM差别不大

注意：开启一个新事物的时候会解锁表

1.先来看下行锁 

第一个session中 

select * from testdemo where id =1 for update 

第二个session 

select * from testdemo where id =1 lock in share mode 

回到第一个session UNLOCK TABLES 并不会解锁 

使用commit 或者 begin或者ROLLBACK 才会解锁 

2.再来看下表锁 

lock table testdemo WRITE 

使用commit，ROLLBACK 并不会解锁 

使用UNLOCK TABLES 或者begin会解锁

### 物理结构修改

面试题：系统运行一段时间，数据量已经很大，这时候系统审计，有张表A需要添加一个字段，并发量白天晚上都很大，请问怎么修改表结构

面试考点：修改表结构会导致表锁，数据量大修改数据很长，导致大量用户阻塞，无法访问。

![1568892699118](C:\Users\AlmostLover\Desktop\MarkDown笔记\数据库\1568892699118.png)

1. 首先创建一个和你要执行的alter操作的表一样的空的表结构
2. 执行我们赋予的表结构的修改，然后copy原表中的数据到新表里面
3. 在原表上创建一个触发器在数据copy的过程中，将原表的更新数据的操作全部更新到新的表中来
4. copy完成之后，用rename table新表代替原表，默认删除原表

## 事务

事务应该具有4个属性：原子性，一致性，隔离性，持久性。这四个属性通常称为ACID特性。

### 事务的隔离级别：

未提交读（READ UNCOMMITED）脏读

已提交读（READ COMMITED）不可重复读

可重复度（REPEATABLE READ）

可串行化（SERIALICABLE）

> mysql默认的事务隔离级别为repeatable-read

### 事务并发问题

**脏读**：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据

**不可重复度**：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据做了更新并提交，导致事务A多次读取同一数据时，结果不一致

**幻读**：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCD等级，但是系统管理员就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读

> 不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需要锁住满足条件的行，解决幻读需要锁表

| 事务隔离级别 | 脏读 | 不可重复读 | 幻读 |
| ------------ | ---- | ---------- | ---- |
| 读未提交     | 是   | 是         | 是   |
| 不可重复度   | 否   | 是         | 是   |
| 可重复度     | 否   | 否         | 是   |
| 串行化       | 否   | 否         | 否   |

**总结**：

事务隔离级别为可重复读时，如果有索引（包括主键索引）的时候，以索引列为条件更新数据，会存在间隙锁间、行锁、页锁的问题，从而锁住一些行；如果没有索引，更新数据时会锁住整张表

事务隔离级别为串行化时，读写操作都会锁住整张表

隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，对于多数应用程序，可以优先考虑把数据库系统的隔离级别设置为Read Commited，它能够避免脏读取，而且具有较好的并发性能。

#### 事务的语法

开启语法：begin、start transcation(推荐)、begin work

事务回滚：rollback

事务提交：commit

还原点：savepoint

## 慢查询

慢查询定义及作用

慢查询日志，顾名思义，就是查询慢的日志，是指mysql记录所有执行超过long_query_time参数设定的时间阈值的SQL语句的日志，该日志能为SQL语句的优化带来很好的帮助。默认情况下，慢查询日志是关闭的，要使用慢查询日志功能，首先要开启慢查询日志功能。

#### 慢查询日志中记录的内容

| **行号** | **内容**                        |
| -------- | ------------------------------- |
| 1        | 用户名 、用户的IP信息、线程ID号 |
| 2        | 执行花费的时间【单位：毫秒】    |
| 3        | 执行获得锁的时间                |
| 4        | 获得的结果行数                  |
| 5        | 扫描的数据行数                  |
| 6        | 这SQL执行的具体时间             |
| 7        | 具体的SQL语句                   |

常用的慢查询日志分析工具（mysqldumpslow）

汇总除查询条件外其他完全相同的SQL，并将分析结果按照参数中所指定的顺序输出。

语法：mysqldumpslow -s r -t 10 slow-mysql.log



## 索引

MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。

可以得到索引的本质：索引是数据结构。

mysql默认存储引擎innodb只显式支持B-Tree( 从技术上来说是B+Tree)索引

- 普通索引：即一个索引只包含单个列，一个表可以有多个单列索引
- 唯一索引：索引列的值必须唯一，但允许有空值
- 复合索引：即一个索引包含多个列
- 聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。
- 非聚簇索引：不是聚簇索引，就是非聚簇索引
             show global variables like "%datadir%";



### 执行计划是什么

使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈
语法
   Explain + SQL语句

#### 执行计划的作用

表的读取顺序

数据读取操作的操作类型

哪些索引可以使用

哪些索引被实际使用

表之间的引用

每张表有多少行被优化器查询

##### 执行计划-ID

select查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序

三种情况
id相同，执行顺序由上至下
id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
id相同不同，同时存在

#### 执行计划-select_type

有哪些

![1568822459159](C:\Users\AlmostLover\Desktop\MarkDown笔记\数据库\1568822459159.png)

查询的类型，主要是用于区别
普通查询、联合查询、子查询等的复杂查询

| **类型**     | **描述**                                                     |
| ------------ | ------------------------------------------------------------ |
| SIMPLE       | 简单的 select 查询,查询中不包含子查询或者UNION               |
| PRIMARY      | 查询中若包含任何复杂的子部分，最外层查询则被标记为           |
| SUBQUERY     | 在SELECT或WHERE列表中包含了子查询                            |
| DERIVED      | 在FROM列表中包含的子查询被标记为DERIVED(衍生)MySQL会递归执行这些子查询, 把结果放在临时表里。 |
| UNION        | 若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED |
| UNION RESULT | 从UNION表获取结果的SELECT                                    |

显示这一行的数据是关于哪张表的

![1568899285742](C:\Users\AlmostLover\Desktop\MarkDown笔记\数据库\1568899285742.png)

type显示的是访问类型，是较为重要的一个指标，结果值从最好到最坏依次是：

system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL 

需要记忆的
system>const>eq_ref>ref>range>index>ALL

system
    表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计
const
表示通过索引一次就找到了
const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快
如将主键置于where列表中，MySQL就能将该查询转换为一个常量

eq_ref
    唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描

ref
 非唯一性索引扫描，返回匹配某个单独值的所有行.

本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体

range
只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引
一般就是在你的where语句中出现了between、<、>、in等的查询
这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。

all
Full Table Scan，将遍历全表以找到匹配的行

实际使用的索引。如果为NULL，则没有使用索引

查询中若使用了覆盖索引，则该索引和查询的select字段重叠

表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好
key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的

![1568900936388](C:\Users\AlmostLover\Desktop\MarkDown笔记\数据库\1568900936388.png)

key_len表示索引使用的字节数，

根据这个值，就可以判断索引使用情况，特别是在组合索引的时候，判断所有的索引字段是否都被查询用到。

char和varchar跟字符编码也有密切的联系,

latin1占用1个字节，gbk占用2个字节，utf8占用3个字节。（不同字符编码占用的存储空间不同）

![1568900959007](C:\Users\AlmostLover\Desktop\MarkDown笔记\数据库\1568900959007.png)

USING index

覆盖索引（Covering Index）,一说为索引覆盖。
理解方式一:就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件,换句话说查询列要被所建的索引覆盖。
理解方式二:索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据;当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含了(或覆盖了)满足查询结果的数据就叫做覆盖索引。

注意：
如果要使用覆盖索引，一定要注意select列表中只取出需要的列，不可select *，
因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降。

![1568901094972](C:\Users\AlmostLover\Desktop\MarkDown笔记\数据库\1568901094972.png)

Using where
表明使用了where过滤

using join buffer
使用了连接缓存：

impossible where
where子句的值总是false，不能用来获取任何元组

## 如何提高MySQL安全性

- 如果MySQL客户端和服务端的连接需要跨越不可信任的网络，那么需要使用ssh隧道来加密该连接的通信
- 使用grant和revoke语句来进行用户访问控制的工作



### MySQL性能优化的21个最佳

- #### 为查询缓存优化你的查询
  
  - 大多数的MySQL服务器都开启了查询缓存，这是提高性能最有效的方法之一，而且这是被MySQL数据库的引擎处理的。当很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表而直接访问缓存结果了
- 这里最主要的问题是，像NOW（），RAND（）或是其他的诸如此类的SQL函数都不会开启查询缓存，因为这些函数的返回是会不定的易变的，所以，需要用一个变量来代替MySQL 函数，从而开启缓存
  
- #### EXPLAIN你的SELECT查询
  - 使用EXPLAIN关键字可以让你知道MySQL是如何处理你的SQL语句的，这可以帮你分析你的查询语句或是表结构的性能瓶颈

- #### 当只要一行数据时使用LIMIT1

  - 加上LIMIT 1可以增加性能，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查找符合记录的数据
  - SELECT 1 FORM user WHERE country=‘China’ LIMIT 1

- #### 为搜索字段建索引

  - 索引不一定就是给主键或是唯一字段，经常搜索的字段都可以建立索引
  - 大篇文章中搜索一个词索引是没有意义的，需要建立MySQL全文索引或自己做一个索引

- #### 当join表的时候使用当前类型的列，并将其索引

  - 如果你的应用程序中有很多join查询，你应该确认两个表中的join的字段是被建立过索引的，这样，MySQL内部会启动为优化join的SQL语句的机制
  - 而且，这些被用来join的字段，应该是相同的类型的

- #### 千万不要ORDER BY RAND（）

  - 打乱取出数据，MySQL会不得不去执行RAND（）函数，很耗CPU时间，而且这是这是为了每一行记录去记行，然后再对其进行排序

- #### 避免SELECT *

  - 从数据库里读出越多的数据，查询就会越慢。而且如果你的数据库服务器和WEB服务器是两台独立的服务器的话，还会增加网络传输的负载

- #### 永远为每一张表设置一个ID

  - 每张表都应该有一个id设置为主键，并且是Int 类型（推荐使用UNSIGNED），并且自增
  - varchar类型设置为主键，会使性能低下
  - 在MySQL数据引擎下，还有一些操作需要使用主键，在这些情况下，主键的性能和设置变得非常重要，比如，集群、分区。

- #### 使用ENUM而不是VARCHAR

  - ENUM是非常快和紧凑的。实际上，其保存的是TINYINT，但其外表上显示为字符串，用来做选项列表
  - 比如一个字段是“国家”，“性别”，“名族”，“状态”或“部门”，取值是固定且有限的，就应该使用ENUM

- #### 尽可能的使用NOT NULL

  - NULL需要额外的空间，并且进行比较的时候会更加复杂

- #### 无缓冲的查询

- #### 将IP地址改为UNSIGNED INT

  - 用int类型存放ip，只需要4个字节，并且你可以有定长的字段，而且，查询上有优势
  - 我们必须使用UNSIGNED INT，因为ip地址会使用整个32位的无符号整型
  - 而且你的查询可以使用INET_ATON（）来把一个字符串IP 转化成一个整型，并使用INET_NTOA()吧一个整型转化成一个字符串ip

- #### 固定长度的表会更快

- #### 垂直分割

- #### 越小的列会更快

- #### 选择正确的存储引擎

  - MySQL中有两个搜索引擎MyISAM和InnoDB，每个引擎都有利有弊
  - MyISAM适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好，甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成，另外，MyISAM对于SELECT COUNT(*)这类的计算都是非常快的
  - InnoDB的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比MyISAM还慢，但是它支持“行锁”，于是在写操作比较多的时候会更优秀，而且他还支持更多的高级应用，比如事务

- #### 使用一个对象关系映射器

  - 使用ORM(Object Relational Mapper)，你能够获得可靠的性能增长。一个ORM可以做所有的事，也能被手动的编写出来。但是，这需要一个高级专家
  - ORM的最重要的是“Lazy Loading"，也就是说，只有在需要去取值的时候才会真正的去做，但是也要小心这种机制的副作用，因为这很可能会因为要去创建很多很小的查询反而会降低性能
  - ORM还可以把你的SQL语句打包成一个事务，这会比单独执行快得多

- #### 什么是乐观锁和悲观锁

  - 悲观锁(Pessimistic Lock)，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样被人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里面就用到了很多这种锁机制，比如行锁、表锁等，读锁、写锁等，都是在操作之前先上锁。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）
  - 乐观锁(Optimistic Lock)，顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似write_condition机制的其实都是提供的乐观锁
  - 两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能 ，所以这种情况下悲观锁就比较适合。

- #### 简述数据库事务在实际中的作用

  - 所谓事务是用户定义的一个数据库操作序列，这些事务要么全做要么全不做，是一个不可分割的工作单位

- #### 导致SQL执行慢的原因

1. 硬件原因。如网络速度慢，内存不足，I/O吞吐量小，磁盘空间满了等。
2. 没有索引或者索引失效（一般互联网公司，DBA会在半夜把表锁了，重新建立一遍索引，因为当你删除某个数据的时候。索引的树结构就不完整了，所以互联网公司的数据做的是假删除，一是为了数据分析，二是为了不破坏索引）
3. 数据过多（分库分表）
4. 服务器调优及各个参数设置（调整my.cnf）

- #### 其他

  - limit的基数较大时使用between
  
  Java开发手册
  
  不要使用外键和  ，影响性能
  
  
  
  业务上具有唯一特性的字段，即使是多个字段的组合，也必须组成唯一索引
  
  
  
  超过三个表禁止join
  
  为了查询效率，字段允许冗余，但必须考虑数据一致性。冗余字段应遵循（不是超长字段）
  
  热点数据放入缓存
  
  全页面不要使用全模糊，使用搜索引擎。